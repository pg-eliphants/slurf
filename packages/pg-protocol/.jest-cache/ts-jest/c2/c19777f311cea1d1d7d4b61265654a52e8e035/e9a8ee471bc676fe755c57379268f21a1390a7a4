[["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\testing\\test-buffers.ts",{"fileContent":"// https://www.postgresql.org/docs/current/protocol-message-formats.html\nimport BufferList from './buffer-list';\n\nconst buffers = {\n    readyForQuery: function () {\n        return new BufferList().add(Buffer.from('I')).join(true, 'Z');\n    },\n\n    authenticationOk: function () {\n        return new BufferList().addInt32(0).join(true, 'R');\n    },\n\n    authenticationCleartextPassword: function () {\n        return new BufferList().addInt32(3).join(true, 'R');\n    },\n\n    authenticationMD5Password: function () {\n        return new BufferList()\n            .addInt32(5)\n            .add(Buffer.from([1, 2, 3, 4]))\n            .join(true, 'R');\n    },\n\n    authenticationSASL: function () {\n        return new BufferList().addInt32(10).addCString('SCRAM-SHA-256').addCString('').join(true, 'R');\n    },\n\n    authenticationSASLContinue: function () {\n        return new BufferList().addInt32(11).addString('data').join(true, 'R');\n    },\n\n    authenticationSASLFinal: function () {\n        return new BufferList().addInt32(12).addString('data').join(true, 'R');\n    },\n\n    parameterStatus: function (name: string, value: string) {\n        return new BufferList().addCString(name).addCString(value).join(true, 'S');\n    },\n\n    backendKeyData: function (processID: number, secretKey: number) {\n        return new BufferList().addInt32(processID).addInt32(secretKey).join(true, 'K');\n    },\n\n    commandComplete: function (string: string) {\n        return new BufferList().addCString(string).join(true, 'C');\n    },\n\n    rowDescription: function (fields: any[]) {\n        fields = fields || [];\n        var buf = new BufferList();\n        buf.addInt16(fields.length);\n        fields.forEach(function (field) {\n            buf.addCString(field.name)\n                .addInt32(field.tableID || 0)\n                .addInt16(field.attributeNumber || 0)\n                .addInt32(field.dataTypeID || 0)\n                .addInt16(field.dataTypeSize || 0)\n                .addInt32(field.typeModifier || 0)\n                .addInt16(field.formatCode || 0);\n        });\n        return buf.join(true, 'T');\n    },\n\n    parameterDescription: function (dataTypeIDs: number[]) {\n        dataTypeIDs = dataTypeIDs || [];\n        var buf = new BufferList();\n        buf.addInt16(dataTypeIDs.length);\n        dataTypeIDs.forEach(function (dataTypeID) {\n            buf.addInt32(dataTypeID);\n        });\n        return buf.join(true, 't');\n    },\n\n    dataRow: function (columns: any[]) {\n        columns = columns || [];\n        var buf = new BufferList();\n        buf.addInt16(columns.length);\n        columns.forEach(function (col) {\n            if (col == null) {\n                buf.addInt32(-1);\n            } else {\n                var strBuf = Buffer.from(col, 'utf8');\n                buf.addInt32(strBuf.length);\n                buf.add(strBuf);\n            }\n        });\n        return buf.join(true, 'D');\n    },\n\n    error: function (fields: any) {\n        return buffers.errorOrNotice(fields).join(true, 'E');\n    },\n\n    notice: function (fields: any) {\n        return buffers.errorOrNotice(fields).join(true, 'N');\n    },\n\n    errorOrNotice: function (fields: any) {\n        fields = fields || [];\n        var buf = new BufferList();\n        fields.forEach(function (field: any) {\n            buf.addChar(field.type);\n            buf.addCString(field.value);\n        });\n        return buf.add(Buffer.from([0])); // terminator\n    },\n\n    parseComplete: function () {\n        return new BufferList().join(true, '1');\n    },\n\n    bindComplete: function () {\n        return new BufferList().join(true, '2');\n    },\n\n    notification: function (id: number, channel: string, payload: string) {\n        return new BufferList().addInt32(id).addCString(channel).addCString(payload).join(true, 'A');\n    },\n\n    emptyQuery: function () {\n        return new BufferList().join(true, 'I');\n    },\n\n    portalSuspended: function () {\n        return new BufferList().join(true, 's');\n    },\n\n    closeComplete: function () {\n        return new BufferList().join(true, '3');\n    },\n\n    copyIn: function (cols: number) {\n        const list = new BufferList()\n            // text mode\n            .addByte(0)\n            // column count\n            .addInt16(cols);\n        for (let i = 0; i < cols; i++) {\n            list.addInt16(i);\n        }\n        return list.join(true, 'G');\n    },\n\n    copyOut: function (cols: number) {\n        const list = new BufferList()\n            // text mode\n            .addByte(0)\n            // column count\n            .addInt16(cols);\n        for (let i = 0; i < cols; i++) {\n            list.addInt16(i);\n        }\n        return list.join(true, 'H');\n    },\n\n    copyData: function (bytes: Buffer) {\n        return new BufferList().add(bytes).join(true, 'd');\n    },\n\n    copyDone: function () {\n        return new BufferList().join(true, 'c');\n    }\n};\n\nexport default buffers;\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/testing/buffer-list.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\testing\\buffer-list.ts",{"fileContent":"export default class BufferList {\n    constructor(public buffers: Buffer[] = []) {}\n\n    public add(buffer: Buffer, front?: boolean) {\n        this.buffers[front ? 'unshift' : 'push'](buffer);\n        return this;\n    }\n\n    public addInt16(val: number, front?: boolean) {\n        return this.add(Buffer.from([val >>> 8, val >>> 0]), front);\n    }\n\n    public getByteLength(initial?: number) {\n        return this.buffers.reduce(function (previous, current) {\n            return previous + current.length;\n        }, initial || 0);\n    }\n\n    public addInt32(val: number, first?: boolean) {\n        return this.add(\n            Buffer.from([(val >>> 24) & 0xff, (val >>> 16) & 0xff, (val >>> 8) & 0xff, (val >>> 0) & 0xff]),\n            first\n        );\n    }\n\n    public addCString(val: string, front?: boolean) {\n        var len = Buffer.byteLength(val);\n        var buffer = Buffer.alloc(len + 1);\n        buffer.write(val);\n        buffer[len] = 0;\n        return this.add(buffer, front);\n    }\n\n    public addString(val: string, front?: boolean) {\n        var len = Buffer.byteLength(val);\n        var buffer = Buffer.alloc(len);\n        buffer.write(val);\n        return this.add(buffer, front);\n    }\n\n    public addChar(char: string, first?: boolean) {\n        return this.add(Buffer.from(char, 'utf8'), first);\n    }\n\n    public addByte(byte: number) {\n        return this.add(Buffer.from([byte]));\n    }\n\n    public join(appendLength?: boolean, char?: string): Buffer {\n        var length = this.getByteLength();\n        if (appendLength) {\n            this.addInt32(length + 4, true);\n            return this.join(false, char);\n        }\n        if (char) {\n            this.addChar(char, true);\n            length++;\n        }\n        var result = Buffer.alloc(length);\n        var index = 0;\n        this.buffers.forEach(function (buffer) {\n            buffer.copy(result, index, 0);\n            index += buffer.length;\n        });\n        return result;\n    }\n\n    public static concat(): Buffer {\n        var total = new BufferList();\n        for (var i = 0; i < arguments.length; i++) {\n            total.add(arguments[i]);\n        }\n        return total.join();\n    }\n}\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\outbound-serializer.test.ts",{"fileContent":"import { strict as assert } from 'node:assert/strict';\nimport { serialize } from './serializer';\nimport BufferList from './testing/buffer-list';\n\ndescribe('serializer', () => {\n    it('builds startup message', function () {\n        const actual = serialize.startup({\n            user: 'brian',\n            database: 'bang'\n        });\n        assert.deepEqual(\n            actual,\n            new BufferList()\n                .addInt16(3)\n                .addInt16(0)\n                .addCString('user')\n                .addCString('brian')\n                .addCString('database')\n                .addCString('bang')\n                .addCString('client_encoding')\n                .addCString('UTF8')\n                .addCString('')\n                .join(true)\n        );\n    });\n\n    it('builds password message', function () {\n        const actual = serialize.password('!');\n        assert.deepEqual(actual, new BufferList().addCString('!').join(true, 'p'));\n    });\n\n    it('builds request ssl message', function () {\n        const actual = serialize.requestSsl();\n        const expected = new BufferList().addInt32(80877103).join(true);\n        assert.deepEqual(actual, expected);\n    });\n\n    it('builds SASLInitialResponseMessage message', function () {\n        const actual = serialize.sendSASLInitialResponseMessage('mech', 'data');\n        assert.deepEqual(actual, new BufferList().addCString('mech').addInt32(4).addString('data').join(true, 'p'));\n    });\n\n    it('builds SCRAMClientFinalMessage message', function () {\n        const actual = serialize.sendSCRAMClientFinalMessage('data');\n        assert.deepEqual(actual, new BufferList().addString('data').join(true, 'p'));\n    });\n\n    it('builds query message', function () {\n        var txt = 'select * from boom';\n        const actual = serialize.query(txt);\n        assert.deepEqual(actual, new BufferList().addCString(txt).join(true, 'Q'));\n    });\n\n    describe('parse message', () => {\n        it('builds parse message', function () {\n            const actual = serialize.parse({ text: '!' });\n            var expected = new BufferList().addCString('').addCString('!').addInt16(0).join(true, 'P');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('builds parse message with named query', function () {\n            const actual = serialize.parse({\n                name: 'boom',\n                text: 'select * from boom',\n                types: []\n            });\n            var expected = new BufferList()\n                .addCString('boom')\n                .addCString('select * from boom')\n                .addInt16(0)\n                .join(true, 'P');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('with multiple parameters', function () {\n            const actual = serialize.parse({\n                name: 'force',\n                text: 'select * from bang where name = $1',\n                types: [1, 2, 3, 4]\n            });\n            var expected = new BufferList()\n                .addCString('force')\n                .addCString('select * from bang where name = $1')\n                .addInt16(4)\n                .addInt32(1)\n                .addInt32(2)\n                .addInt32(3)\n                .addInt32(4)\n                .join(true, 'P');\n            assert.deepEqual(actual, expected);\n        });\n    });\n\n    describe('bind messages', function () {\n        it('with no values', function () {\n            const actual = serialize.bind();\n\n            var expectedBuffer = new BufferList()\n                .addCString('')\n                .addCString('')\n                .addInt16(0)\n                .addInt16(0)\n                .addInt16(0)\n                .join(true, 'B');\n            assert.deepEqual(actual, expectedBuffer);\n        });\n\n        it('with named statement, portal, and values', function () {\n            const actual = serialize.bind({\n                portal: 'bang',\n                statement: 'woo',\n                values: ['1', 'hi', null, 'zing']\n            });\n            var expectedBuffer = new BufferList()\n                .addCString('bang') // portal name\n                .addCString('woo') // statement name\n                .addInt16(4)\n                .addInt16(0)\n                .addInt16(0)\n                .addInt16(0)\n                .addInt16(0)\n                .addInt16(4)\n                .addInt32(1)\n                .add(Buffer.from('1'))\n                .addInt32(2)\n                .add(Buffer.from('hi'))\n                .addInt32(-1)\n                .addInt32(4)\n                .add(Buffer.from('zing'))\n                .addInt16(0)\n                .join(true, 'B');\n            assert.deepEqual(actual, expectedBuffer);\n        });\n    });\n\n    it('with custom valueMapper', function () {\n        const actual = serialize.bind({\n            portal: 'bang',\n            statement: 'woo',\n            values: ['1', 'hi', null, 'zing'],\n            valueMapper: () => null\n        });\n        var expectedBuffer = new BufferList()\n            .addCString('bang') // portal name\n            .addCString('woo') // statement name\n            .addInt16(4)\n            .addInt16(0)\n            .addInt16(0)\n            .addInt16(0)\n            .addInt16(0)\n            .addInt16(4)\n            .addInt32(-1)\n            .addInt32(-1)\n            .addInt32(-1)\n            .addInt32(-1)\n            .addInt16(0)\n            .join(true, 'B');\n        assert.deepEqual(actual, expectedBuffer);\n    });\n\n    it('with named statement, portal, and buffer value', function () {\n        const actual = serialize.bind({\n            portal: 'bang',\n            statement: 'woo',\n            values: ['1', 'hi', null, Buffer.from('zing', 'utf8')]\n        });\n        var expectedBuffer = new BufferList()\n            .addCString('bang') // portal name\n            .addCString('woo') // statement name\n            .addInt16(4) // value count\n            .addInt16(0) // string\n            .addInt16(0) // string\n            .addInt16(0) // string\n            .addInt16(1) // binary\n            .addInt16(4)\n            .addInt32(1)\n            .add(Buffer.from('1'))\n            .addInt32(2)\n            .add(Buffer.from('hi'))\n            .addInt32(-1)\n            .addInt32(4)\n            .add(Buffer.from('zing', 'utf-8'))\n            .addInt16(0)\n            .join(true, 'B');\n        assert.deepEqual(actual, expectedBuffer);\n    });\n\n    describe('builds execute message', function () {\n        it('for unamed portal with no row limit', function () {\n            const actual = serialize.execute();\n            var expectedBuffer = new BufferList().addCString('').addInt32(0).join(true, 'E');\n            assert.deepEqual(actual, expectedBuffer);\n        });\n\n        it('for named portal with row limit', function () {\n            const actual = serialize.execute({\n                portal: 'my favorite portal',\n                rows: 100\n            });\n            var expectedBuffer = new BufferList().addCString('my favorite portal').addInt32(100).join(true, 'E');\n            assert.deepEqual(actual, expectedBuffer);\n        });\n    });\n\n    it('builds flush command', function () {\n        const actual = serialize.flush();\n        var expected = new BufferList().join(true, 'H');\n        assert.deepEqual(actual, expected);\n    });\n\n    it('builds sync command', function () {\n        const actual = serialize.sync();\n        var expected = new BufferList().join(true, 'S');\n        assert.deepEqual(actual, expected);\n    });\n\n    it('builds end command', function () {\n        const actual = serialize.end();\n        var expected = Buffer.from([0x58, 0, 0, 0, 4]);\n        assert.deepEqual(actual, expected);\n    });\n\n    describe('builds describe command', function () {\n        it('describe statement', function () {\n            const actual = serialize.describe({ type: 'S', name: 'bang' });\n            var expected = new BufferList().addChar('S').addCString('bang').join(true, 'D');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('describe unnamed portal', function () {\n            const actual = serialize.describe({ type: 'P' });\n            var expected = new BufferList().addChar('P').addCString('').join(true, 'D');\n            assert.deepEqual(actual, expected);\n        });\n    });\n\n    describe('builds close command', function () {\n        it('describe statement', function () {\n            const actual = serialize.close({ type: 'S', name: 'bang' });\n            var expected = new BufferList().addChar('S').addCString('bang').join(true, 'C');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('describe unnamed portal', function () {\n            const actual = serialize.close({ type: 'P' });\n            var expected = new BufferList().addChar('P').addCString('').join(true, 'C');\n            assert.deepEqual(actual, expected);\n        });\n    });\n\n    describe('copy messages', function () {\n        it('builds copyFromChunk', () => {\n            const actual = serialize.copyData(Buffer.from([1, 2, 3]));\n            const expected = new BufferList().add(Buffer.from([1, 2, 3])).join(true, 'd');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('builds copy fail', () => {\n            const actual = serialize.copyFail('err!');\n            const expected = new BufferList().addCString('err!').join(true, 'f');\n            assert.deepEqual(actual, expected);\n        });\n\n        it('builds copy done', () => {\n            const actual = serialize.copyDone();\n            const expected = new BufferList().join(true, 'c');\n            assert.deepEqual(actual, expected);\n        });\n    });\n\n    it('builds cancel message', () => {\n        const actual = serialize.cancel(3, 4);\n        const expected = new BufferList().addInt16(1234).addInt16(5678).addInt32(3).addInt32(4).join(true);\n        assert.deepEqual(actual, expected);\n    });\n});\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/testing/buffer-list.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\b.ts",{"fileContent":"// file for microbenchmarking\r\n\r\nimport { Writer } from './buffer-writer'\r\nimport { serialize } from './index'\r\nimport { BufferReader } from './buffer-reader'\r\n\r\nconst LOOPS = 1000\r\nlet count = 0\r\nlet start = Date.now()\r\nconst writer = new Writer()\r\n\r\nconst reader = new BufferReader()\r\nconst buffer = Buffer.from([33, 33, 33, 33, 33, 33, 33, 0])\r\n\r\nconst run = () => {\r\n  if (count > LOOPS) {\r\n    console.log(Date.now() - start)\r\n    return\r\n  }\r\n  count++\r\n  for (let i = 0; i < LOOPS; i++) {\r\n    reader.setBuffer(0, buffer)\r\n    reader.cstring()\r\n  }\r\n  setImmediate(run)\r\n}\r\n\r\nrun()\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts","C:/repos/node-postgres/packages/pg-protocol/src/index.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts","C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\buffer-writer.ts",{"fileContent":"//binary data writer tuned for encoding binary specific to the postgres binary protocol\n\nexport class Writer {\n    private buffer: Buffer;\n    private offset: number = 5;\n    private headerPosition: number = 0;\n    constructor(private size = 256) {\n        this.buffer = Buffer.allocUnsafe(size);\n    }\n\n    private ensure(size: number): void {\n        var remaining = this.buffer.length - this.offset;\n        if (remaining < size) {\n            var oldBuffer = this.buffer;\n            // exponential growth factor of around ~ 1.5\n            // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\n            var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;\n            this.buffer = Buffer.allocUnsafe(newSize);\n            oldBuffer.copy(this.buffer);\n        }\n    }\n\n    public addInt32(num: number): Writer {\n        this.ensure(4);\n        this.buffer[this.offset++] = (num >>> 24) & 0xff;\n        this.buffer[this.offset++] = (num >>> 16) & 0xff;\n        this.buffer[this.offset++] = (num >>> 8) & 0xff;\n        this.buffer[this.offset++] = (num >>> 0) & 0xff;\n        return this;\n    }\n\n    public addInt16(num: number): Writer {\n        this.ensure(2);\n        this.buffer[this.offset++] = (num >>> 8) & 0xff;\n        this.buffer[this.offset++] = (num >>> 0) & 0xff;\n        return this;\n    }\n\n    public addCString(string: string): Writer {\n        if (!string) {\n            this.ensure(1);\n        } else {\n            var len = Buffer.byteLength(string);\n            this.ensure(len + 1); // +1 for null terminator\n            this.buffer.write(string, this.offset, 'utf-8');\n            this.offset += len;\n        }\n\n        this.buffer[this.offset++] = 0; // null terminator\n        return this;\n    }\n\n    public addString(string: string = ''): Writer {\n        var len = Buffer.byteLength(string);\n        this.ensure(len);\n        this.buffer.write(string, this.offset);\n        this.offset += len;\n        return this;\n    }\n\n    public add(otherBuffer: Buffer): Writer {\n        this.ensure(otherBuffer.length);\n        otherBuffer.copy(this.buffer, this.offset);\n        this.offset += otherBuffer.length;\n        return this;\n    }\n\n    private join(code?: number): Buffer {\n        if (code) {\n            this.buffer[this.headerPosition] = code;\n            //length is everything in this packet minus the code\n            const length = this.offset - (this.headerPosition + 1);\n            this.buffer.writeInt32BE(length, this.headerPosition + 1);\n        }\n        return this.buffer.slice(code ? 0 : 5, this.offset);\n    }\n\n    public flush(code?: number): Buffer {\n        var result = this.join(code);\n        this.offset = 5;\n        this.headerPosition = 0;\n        this.buffer = Buffer.allocUnsafe(this.size);\n        return result;\n    }\n}\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\messages.ts",{"fileContent":"export type Mode = 'text' | 'binary';\n\nexport type MessageName =\n    | 'parseComplete'\n    | 'bindComplete'\n    | 'closeComplete'\n    | 'noData'\n    | 'portalSuspended'\n    | 'replicationStart'\n    | 'emptyQuery'\n    | 'copyDone'\n    | 'copyData'\n    | 'rowDescription'\n    | 'parameterDescription'\n    | 'parameterStatus'\n    | 'backendKeyData'\n    | 'notification'\n    | 'readyForQuery'\n    | 'commandComplete'\n    | 'dataRow'\n    | 'copyInResponse'\n    | 'copyOutResponse'\n    | 'authenticationOk'\n    | 'authenticationMD5Password'\n    | 'authenticationCleartextPassword'\n    | 'authenticationSASL'\n    | 'authenticationSASLContinue'\n    | 'authenticationSASLFinal'\n    | 'error'\n    | 'notice';\n\nexport interface BackendMessage {\n    name: MessageName;\n    length: number;\n}\n\nexport const parseComplete: BackendMessage = {\n    name: 'parseComplete',\n    length: 5\n};\n\nexport const bindComplete: BackendMessage = {\n    name: 'bindComplete',\n    length: 5\n};\n\nexport const closeComplete: BackendMessage = {\n    name: 'closeComplete',\n    length: 5\n};\n\nexport const noData: BackendMessage = {\n    name: 'noData',\n    length: 5\n};\n\nexport const portalSuspended: BackendMessage = {\n    name: 'portalSuspended',\n    length: 5\n};\n\nexport const replicationStart: BackendMessage = {\n    name: 'replicationStart',\n    length: 4\n};\n\nexport const emptyQuery: BackendMessage = {\n    name: 'emptyQuery',\n    length: 4\n};\n\nexport const copyDone: BackendMessage = {\n    name: 'copyDone',\n    length: 4\n};\n\ninterface NoticeOrError {\n    message?: string;\n    severity?: string;\n    code?: string;\n    detail?: string;\n    hint?: string;\n    position?: string;\n    internalPosition?: string;\n    internalQuery?: string;\n    where?: string;\n    schema?: string;\n    table?: string;\n    column?: string;\n    dataType?: string;\n    constraint?: string;\n    file?: string;\n    line?: string;\n    routine?: string;\n}\n\nexport class DatabaseError extends Error implements NoticeOrError {\n    public severity?: string;\n    public code?: string;\n    public detail?: string;\n    public hint?: string;\n    public position?: string;\n    public internalPosition?: string;\n    public internalQuery?: string;\n    public where?: string;\n    public schema?: string;\n    public table?: string;\n    public column?: string;\n    public dataType?: string;\n    public constraint?: string;\n    public file?: string;\n    public line?: string;\n    public routine?: string;\n    constructor(\n        message: string,\n        public readonly length: number,\n        public override readonly name: MessageName\n    ) {\n        super(message);\n    }\n}\n\nexport class CopyDataMessage {\n    public readonly name = 'copyData';\n    constructor(\n        public readonly length: number,\n        public readonly chunk: Buffer\n    ) {}\n}\n\nexport class CopyResponse {\n    public readonly columnTypes: number[];\n    constructor(\n        public readonly length: number,\n        public readonly name: MessageName,\n        public readonly binary: boolean,\n        columnCount: number\n    ) {\n        this.columnTypes = new Array(columnCount);\n    }\n}\n\nexport class Field {\n    constructor(\n        public readonly name: string,\n        public readonly tableID: number,\n        public readonly columnID: number,\n        public readonly dataTypeID: number,\n        public readonly dataTypeSize: number,\n        public readonly dataTypeModifier: number,\n        public readonly format: Mode\n    ) {}\n}\n\nexport class RowDescriptionMessage {\n    public readonly name: MessageName = 'rowDescription';\n    public readonly fields: Field[];\n    constructor(\n        public readonly length: number,\n        public readonly fieldCount: number\n    ) {\n        this.fields = new Array(this.fieldCount);\n    }\n}\n\nexport class ParameterDescriptionMessage {\n    public readonly name: MessageName = 'parameterDescription';\n    public readonly dataTypeIDs: number[];\n    constructor(\n        public readonly length: number,\n        public readonly parameterCount: number\n    ) {\n        this.dataTypeIDs = new Array(this.parameterCount);\n    }\n}\n\nexport class ParameterStatusMessage {\n    public readonly name: MessageName = 'parameterStatus';\n    constructor(\n        public readonly length: number,\n        public readonly parameterName: string,\n        public readonly parameterValue: string\n    ) {}\n}\n\nexport class AuthenticationMD5Password implements BackendMessage {\n    public readonly name: MessageName = 'authenticationMD5Password';\n    constructor(\n        public readonly length: number,\n        public readonly salt: Buffer\n    ) {}\n}\n\nexport class BackendKeyDataMessage {\n    public readonly name: MessageName = 'backendKeyData';\n    constructor(\n        public readonly length: number,\n        public readonly processID: number,\n        public readonly secretKey: number\n    ) {}\n}\n\nexport class NotificationResponseMessage {\n    public readonly name: MessageName = 'notification';\n    constructor(\n        public readonly length: number,\n        public readonly processId: number,\n        public readonly channel: string,\n        public readonly payload: string\n    ) {}\n}\n\nexport class ReadyForQueryMessage {\n    public readonly name: MessageName = 'readyForQuery';\n    constructor(\n        public readonly length: number,\n        public readonly status: string\n    ) {}\n}\n\nexport class CommandCompleteMessage {\n    public readonly name: MessageName = 'commandComplete';\n    constructor(\n        public readonly length: number,\n        public readonly text: string\n    ) {}\n}\n\nexport class DataRowMessage {\n    public readonly fieldCount: number;\n    public readonly name: MessageName = 'dataRow';\n    constructor(\n        public length: number,\n        public fields: any[]\n    ) {\n        this.fieldCount = fields.length;\n    }\n}\n\nexport class NoticeMessage implements BackendMessage, NoticeOrError {\n    constructor(\n        public readonly length: number,\n        public readonly message: string\n    ) {}\n    public readonly name = 'notice';\n    public severity?: string;\n    public code?: string;\n    public detail?: string;\n    public hint?: string;\n    public position?: string;\n    public internalPosition?: string;\n    public internalQuery?: string;\n    public where?: string;\n    public schema?: string;\n    public table?: string;\n    public column?: string;\n    public dataType?: string;\n    public constraint?: string;\n    public file?: string;\n    public line?: string;\n    public routine?: string;\n}\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\parser.ts",{"fileContent":"import { TransformOptions } from 'stream';\nimport {\n    Mode,\n    bindComplete,\n    parseComplete,\n    closeComplete,\n    noData,\n    portalSuspended,\n    copyDone,\n    replicationStart,\n    emptyQuery,\n    ReadyForQueryMessage,\n    CommandCompleteMessage,\n    CopyDataMessage,\n    CopyResponse,\n    NotificationResponseMessage,\n    RowDescriptionMessage,\n    ParameterDescriptionMessage,\n    Field,\n    DataRowMessage,\n    ParameterStatusMessage,\n    BackendKeyDataMessage,\n    DatabaseError,\n    BackendMessage,\n    MessageName,\n    AuthenticationMD5Password,\n    NoticeMessage\n} from './messages';\nimport { BufferReader } from './buffer-reader';\nimport { strict as assert } from 'node:assert/strict';\n\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\n\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\n\nexport type Packet = {\n    code: number;\n    packet: Buffer;\n};\n\nconst emptyBuffer = Buffer.allocUnsafe(0);\n\ntype StreamOptions = TransformOptions & {\n    mode: Mode;\n};\n\nconst enum MessageCodes {\n    DataRow = 0x44, // D\n    ParseComplete = 0x31, // 1\n    BindComplete = 0x32, // 2\n    CloseComplete = 0x33, // 3\n    CommandComplete = 0x43, // C\n    ReadyForQuery = 0x5a, // Z\n    NoData = 0x6e, // n\n    NotificationResponse = 0x41, // A\n    AuthenticationResponse = 0x52, // R\n    ParameterStatus = 0x53, // S\n    BackendKeyData = 0x4b, // K\n    ErrorMessage = 0x45, // E\n    NoticeMessage = 0x4e, // N\n    RowDescriptionMessage = 0x54, // T\n    ParameterDescriptionMessage = 0x74, // t\n    PortalSuspended = 0x73, // s\n    ReplicationStart = 0x57, // W\n    EmptyQuery = 0x49, // I\n    CopyIn = 0x47, // G\n    CopyOut = 0x48, // H\n    CopyDone = 0x63, // c\n    CopyData = 0x64 // d\n}\n\nexport type MessageCallback = (msg: BackendMessage) => void;\n\nexport class Parser {\n    private buffer: Buffer = emptyBuffer;\n    private bufferLength: number = 0;\n    private bufferOffset: number = 0;\n    private reader = new BufferReader();\n    //private mode: Mode;\n\n    // so far the \"index.ts\" calls the constructor without arguments\n    constructor(opts?: StreamOptions) {\n        if (opts?.mode === 'binary') {\n            throw new Error('Binary mode not supported yet');\n        }\n        //this.mode = opts?.mode || 'text';\n    }\n\n    public parse(buffer: Buffer, callback: MessageCallback) {\n        this.mergeBuffer(buffer);\n        const bufferFullLength = this.bufferOffset + this.bufferLength;\n        let offset = this.bufferOffset;\n        while (offset + HEADER_LENGTH <= bufferFullLength) {\n            // code is 1 byte long - it identifies the message type\n            const code = this.buffer[offset];\n            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n            const fullMessageLength = CODE_LENGTH + length;\n            if (fullMessageLength + offset <= bufferFullLength) {\n                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n                callback(message);\n                offset += fullMessageLength;\n            } else {\n                break;\n            }\n        }\n        if (offset === bufferFullLength) {\n            // No more use for the buffer\n            this.buffer = emptyBuffer;\n            this.bufferLength = 0;\n            this.bufferOffset = 0;\n        } else {\n            // Adjust the cursors of remainingBuffer\n            this.bufferLength = bufferFullLength - offset;\n            this.bufferOffset = offset;\n        }\n    }\n\n    private mergeBuffer(buffer: Buffer): void {\n        if (this.bufferLength > 0) {\n            const newLength = this.bufferLength + buffer.byteLength;\n            const newFullLength = newLength + this.bufferOffset;\n            if (newFullLength > this.buffer.byteLength) {\n                // We can't concat the new buffer with the remaining one\n                let newBuffer: Buffer;\n                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n                    newBuffer = this.buffer;\n                } else {\n                    // Allocate a new larger buffer\n                    let newBufferLength = this.buffer.byteLength * 2;\n                    while (newLength >= newBufferLength) {\n                        newBufferLength *= 2;\n                    }\n                    newBuffer = Buffer.allocUnsafe(newBufferLength);\n                }\n                // Move the remaining buffer to the new one\n                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n                this.buffer = newBuffer;\n                this.bufferOffset = 0;\n            }\n            // Concat the new buffer with the remaining one\n            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n            this.bufferLength = newLength;\n        } else {\n            this.buffer = buffer;\n            this.bufferOffset = 0;\n            this.bufferLength = buffer.byteLength;\n        }\n    }\n\n    private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\n        switch (code) {\n            case MessageCodes.BindComplete:\n                return bindComplete;\n            case MessageCodes.ParseComplete:\n                return parseComplete;\n            case MessageCodes.CloseComplete:\n                return closeComplete;\n            case MessageCodes.NoData:\n                return noData;\n            case MessageCodes.PortalSuspended:\n                return portalSuspended;\n            case MessageCodes.CopyDone:\n                return copyDone;\n            case MessageCodes.ReplicationStart:\n                return replicationStart;\n            case MessageCodes.EmptyQuery:\n                return emptyQuery;\n            case MessageCodes.DataRow:\n                return this.parseDataRowMessage(offset, length, bytes);\n            case MessageCodes.CommandComplete:\n                return this.parseCommandCompleteMessage(offset, length, bytes);\n            case MessageCodes.ReadyForQuery:\n                return this.parseReadyForQueryMessage(offset, length, bytes);\n            case MessageCodes.NotificationResponse:\n                return this.parseNotificationMessage(offset, length, bytes);\n            case MessageCodes.AuthenticationResponse:\n                return this.parseAuthenticationResponse(offset, length, bytes);\n            case MessageCodes.ParameterStatus:\n                return this.parseParameterStatusMessage(offset, length, bytes);\n            case MessageCodes.BackendKeyData:\n                return this.parseBackendKeyData(offset, length, bytes);\n            case MessageCodes.ErrorMessage:\n                return this.parseErrorMessage(offset, length, bytes, 'error');\n            case MessageCodes.NoticeMessage:\n                return this.parseErrorMessage(offset, length, bytes, 'notice');\n            case MessageCodes.RowDescriptionMessage:\n                return this.parseRowDescriptionMessage(offset, length, bytes);\n            case MessageCodes.ParameterDescriptionMessage:\n                return this.parseParameterDescriptionMessage(offset, length, bytes);\n            case MessageCodes.CopyIn:\n                return this.parseCopyInMessage(offset, length, bytes);\n            case MessageCodes.CopyOut:\n                return this.parseCopyOutMessage(offset, length, bytes);\n            case MessageCodes.CopyData:\n                return this.parseCopyData(offset, length, bytes);\n            default:\n                assert.fail(`unknown message code: ${code.toString(16)}`);\n        }\n    }\n\n    private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const status = this.reader.string(1);\n        return new ReadyForQueryMessage(length, status);\n    }\n\n    private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const text = this.reader.cstring();\n        return new CommandCompleteMessage(length, text);\n    }\n\n    private parseCopyData(offset: number, length: number, bytes: Buffer) {\n        const chunk = bytes.slice(offset, offset + (length - 4));\n        return new CopyDataMessage(length, chunk);\n    }\n\n    private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n    }\n\n    private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n    }\n\n    private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\n        this.reader.setBuffer(offset, bytes);\n        const isBinary = this.reader.byte() !== 0;\n        const columnCount = this.reader.int16();\n        const message = new CopyResponse(length, messageName, isBinary, columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            message.columnTypes[i] = this.reader.int16();\n        }\n        return message;\n    }\n\n    private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const processId = this.reader.int32();\n        const channel = this.reader.cstring();\n        const payload = this.reader.cstring();\n        return new NotificationResponseMessage(length, processId, channel, payload);\n    }\n\n    private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const message = new RowDescriptionMessage(length, fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            message.fields[i] = this.parseField();\n        }\n        return message;\n    }\n\n    private parseField(): Field {\n        const name = this.reader.cstring();\n        const tableID = this.reader.int32();\n        const columnID = this.reader.int16();\n        const dataTypeID = this.reader.int32();\n        const dataTypeSize = this.reader.int16();\n        const dataTypeModifier = this.reader.int32();\n        const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n        return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n\n    private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const parameterCount = this.reader.int16();\n        const message = new ParameterDescriptionMessage(length, parameterCount);\n        for (let i = 0; i < parameterCount; i++) {\n            message.dataTypeIDs[i] = this.reader.int32();\n        }\n        return message;\n    }\n\n    private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const fields: any[] = new Array(fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            const len = this.reader.int32();\n            // a -1 for length means the value of the field is null\n            fields[i] = len === -1 ? null : this.reader.string(len);\n        }\n        return new DataRowMessage(length, fields);\n    }\n\n    private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const name = this.reader.cstring();\n        const value = this.reader.cstring();\n        return new ParameterStatusMessage(length, name, value);\n    }\n\n    private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const processID = this.reader.int32();\n        const secretKey = this.reader.int32();\n        return new BackendKeyDataMessage(length, processID, secretKey);\n    }\n\n    public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\n        this.reader.setBuffer(offset, bytes);\n        const code = this.reader.int32();\n        // TODO(bmc): maybe better types here\n        const message: BackendMessage & any = {\n            name: 'authenticationOk',\n            length\n        };\n\n        switch (code) {\n            case 0: // AuthenticationOk\n                break;\n            case 3: // AuthenticationCleartextPassword\n                if (message.length === 8) {\n                    message.name = 'authenticationCleartextPassword';\n                }\n                break;\n            case 5: // AuthenticationMD5Password\n                if (message.length === 12) {\n                    message.name = 'authenticationMD5Password';\n                    const salt = this.reader.bytes(4);\n                    return new AuthenticationMD5Password(length, salt);\n                }\n                break;\n            case 10: // AuthenticationSASL\n                message.name = 'authenticationSASL';\n                message.mechanisms = [];\n                let mechanism: string;\n                do {\n                    mechanism = this.reader.cstring();\n\n                    if (mechanism) {\n                        message.mechanisms.push(mechanism);\n                    }\n                } while (mechanism);\n                break;\n            case 11: // AuthenticationSASLContinue\n                message.name = 'authenticationSASLContinue';\n                message.data = this.reader.string(length - 8);\n                break;\n            case 12: // AuthenticationSASLFinal\n                message.name = 'authenticationSASLFinal';\n                message.data = this.reader.string(length - 8);\n                break;\n            default:\n                throw new Error('Unknown authenticationOk message type ' + code);\n        }\n        return message;\n    }\n\n    private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\n        this.reader.setBuffer(offset, bytes);\n        const fields: Record<string, string> = {};\n        let fieldType = this.reader.string(1);\n        while (fieldType !== '\\0') {\n            fields[fieldType] = this.reader.cstring();\n            fieldType = this.reader.string(1);\n        }\n\n        const messageValue = fields.M;\n\n        const message =\n            name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name);\n\n        message.severity = fields.S;\n        message.code = fields.C;\n        message.detail = fields.D;\n        message.hint = fields.H;\n        message.position = fields.P;\n        message.internalPosition = fields.p;\n        message.internalQuery = fields.q;\n        message.where = fields.W;\n        message.schema = fields.s;\n        message.table = fields.t;\n        message.column = fields.c;\n        message.dataType = fields.d;\n        message.constraint = fields.n;\n        message.file = fields.F;\n        message.line = fields.L;\n        message.routine = fields.R;\n        return message;\n    }\n}\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\serializer.ts",{"fileContent":"import { Writer } from './buffer-writer';\n\nconst enum code {\n    startup = 0x70,\n    query = 0x51,\n    parse = 0x50,\n    bind = 0x42,\n    execute = 0x45,\n    flush = 0x48,\n    sync = 0x53,\n    end = 0x58,\n    close = 0x43,\n    describe = 0x44,\n    copyFromChunk = 0x64,\n    copyDone = 0x63,\n    copyFail = 0x66\n}\n\nconst writer = new Writer();\n\nconst startup = (opts: Record<string, string>): Buffer => {\n    // protocol version\n    writer.addInt16(3).addInt16(0);\n    for (const key of Object.keys(opts)) {\n        writer.addCString(key).addCString(opts[key]);\n    }\n\n    writer.addCString('client_encoding').addCString('UTF8');\n\n    var bodyBuffer = writer.addCString('').flush();\n    // this message is sent without a code\n\n    var length = bodyBuffer.length + 4;\n\n    return new Writer().addInt32(length).add(bodyBuffer).flush();\n};\n\nconst requestSsl = (): Buffer => {\n    const response = Buffer.allocUnsafe(8);\n    response.writeInt32BE(8, 0);\n    response.writeInt32BE(80877103, 4);\n    return response;\n};\n\nconst password = (password: string): Buffer => {\n    return writer.addCString(password).flush(code.startup);\n};\n\nconst sendSASLInitialResponseMessage = function (mechanism: string, initialResponse: string): Buffer {\n    // 0x70 = 'p'\n    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);\n\n    return writer.flush(code.startup);\n};\n\nconst sendSCRAMClientFinalMessage = function (additionalData: string): Buffer {\n    return writer.addString(additionalData).flush(code.startup);\n};\n\nconst query = (text: string): Buffer => {\n    return writer.addCString(text).flush(code.query);\n};\n\ntype ParseOpts = {\n    name?: string;\n    types?: number[];\n    text: string;\n};\n\nconst emptyArray: any[] = [];\n\nconst parse = (query: ParseOpts): Buffer => {\n    // expect something like this:\n    // { name: 'queryName',\n    //   text: 'select * from blah',\n    //   types: ['int8', 'bool'] }\n\n    // normalize missing query names to allow for null\n    const name = query.name || '';\n    if (name.length > 63) {\n        /* eslint-disable no-console */\n        console.error('Warning! Postgres only supports 63 characters for query names.');\n        console.error('You supplied %s (%s)', name, name.length);\n        console.error('This can cause conflicts and silent errors executing queries');\n        /* eslint-enable no-console */\n    }\n\n    const types = query.types || emptyArray;\n\n    var len = types.length;\n\n    var buffer = writer\n        .addCString(name) // name of query\n        .addCString(query.text) // actual query text\n        .addInt16(len);\n\n    for (var i = 0; i < len; i++) {\n        buffer.addInt32(types[i]);\n    }\n\n    return writer.flush(code.parse);\n};\n\ntype ValueMapper = (param: any, index: number) => any;\n\ntype BindOpts = {\n    portal?: string;\n    binary?: boolean;\n    statement?: string;\n    values?: any[];\n    // optional map from JS value to postgres value per parameter\n    valueMapper?: ValueMapper;\n};\n\nconst paramWriter = new Writer();\n\n// make this a const enum so typescript will inline the value\nconst enum ParamType {\n    STRING = 0,\n    BINARY = 1\n}\n\nconst writeValues = function (values: any[], valueMapper?: ValueMapper): void {\n    for (let i = 0; i < values.length; i++) {\n        const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];\n        if (mappedVal == null) {\n            // add the param type (string) to the writer\n            writer.addInt16(ParamType.STRING);\n            // write -1 to the param writer to indicate null\n            paramWriter.addInt32(-1);\n        } else if (mappedVal instanceof Buffer) {\n            // add the param type (binary) to the writer\n            writer.addInt16(ParamType.BINARY);\n            // add the buffer to the param writer\n            paramWriter.addInt32(mappedVal.length);\n            paramWriter.add(mappedVal);\n        } else {\n            // add the param type (string) to the writer\n            writer.addInt16(ParamType.STRING);\n            paramWriter.addInt32(Buffer.byteLength(mappedVal));\n            paramWriter.addString(mappedVal);\n        }\n    }\n};\n\nconst bind = (config: BindOpts = {}): Buffer => {\n    // normalize config\n    const portal = config.portal || '';\n    const statement = config.statement || '';\n    const binary = config.binary || false;\n    const values = config.values || emptyArray;\n    const len = values.length;\n\n    writer.addCString(portal).addCString(statement);\n    writer.addInt16(len);\n\n    writeValues(values, config.valueMapper);\n\n    writer.addInt16(len);\n    writer.add(paramWriter.flush());\n\n    // format code\n    writer.addInt16(binary ? ParamType.BINARY : ParamType.STRING);\n    return writer.flush(code.bind);\n};\n\ntype ExecOpts = {\n    portal?: string;\n    rows?: number;\n};\n\nconst emptyExecute = Buffer.from([code.execute, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nconst execute = (config?: ExecOpts): Buffer => {\n    // this is the happy path for most queries\n    if (!config || (!config.portal && !config.rows)) {\n        return emptyExecute;\n    }\n\n    const portal = config.portal || '';\n    const rows = config.rows || 0;\n\n    const portalLength = Buffer.byteLength(portal);\n    const len = 4 + portalLength + 1 + 4;\n    // one extra bit for code\n    const buff = Buffer.allocUnsafe(1 + len);\n    buff[0] = code.execute;\n    buff.writeInt32BE(len, 1);\n    buff.write(portal, 5, 'utf-8');\n    buff[portalLength + 5] = 0; // null terminate portal cString\n    buff.writeUInt32BE(rows, buff.length - 4);\n    return buff;\n};\n\nconst cancel = (processID: number, secretKey: number): Buffer => {\n    const buffer = Buffer.allocUnsafe(16);\n    buffer.writeInt32BE(16, 0);\n    buffer.writeInt16BE(1234, 4);\n    buffer.writeInt16BE(5678, 6);\n    buffer.writeInt32BE(processID, 8);\n    buffer.writeInt32BE(secretKey, 12);\n    return buffer;\n};\n\ntype PortalOpts = {\n    type: 'S' | 'P';\n    name?: string;\n};\n\nconst cstringMessage = (code: code, string: string): Buffer => {\n    const stringLen = Buffer.byteLength(string);\n    const len = 4 + stringLen + 1;\n    // one extra bit for code\n    const buffer = Buffer.allocUnsafe(1 + len);\n    buffer[0] = code;\n    buffer.writeInt32BE(len, 1);\n    buffer.write(string, 5, 'utf-8');\n    buffer[len] = 0; // null terminate cString\n    return buffer;\n};\n\nconst emptyDescribePortal = writer.addCString('P').flush(code.describe);\nconst emptyDescribeStatement = writer.addCString('S').flush(code.describe);\n\nconst describe = (msg: PortalOpts): Buffer => {\n    return msg.name\n        ? cstringMessage(code.describe, `${msg.type}${msg.name || ''}`)\n        : msg.type === 'P'\n        ? emptyDescribePortal\n        : emptyDescribeStatement;\n};\n\nconst close = (msg: PortalOpts): Buffer => {\n    const text = `${msg.type}${msg.name || ''}`;\n    return cstringMessage(code.close, text);\n};\n\nconst copyData = (chunk: Buffer): Buffer => {\n    return writer.add(chunk).flush(code.copyFromChunk);\n};\n\nconst copyFail = (message: string): Buffer => {\n    return cstringMessage(code.copyFail, message);\n};\n\nconst codeOnlyBuffer = (code: code): Buffer => Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);\n\nconst flushBuffer = codeOnlyBuffer(code.flush);\nconst syncBuffer = codeOnlyBuffer(code.sync);\nconst endBuffer = codeOnlyBuffer(code.end);\nconst copyDoneBuffer = codeOnlyBuffer(code.copyDone);\n\nconst serialize = {\n    startup,\n    password,\n    requestSsl,\n    sendSASLInitialResponseMessage,\n    sendSCRAMClientFinalMessage,\n    query,\n    parse,\n    bind,\n    execute,\n    describe,\n    close,\n    flush: () => flushBuffer,\n    sync: () => syncBuffer,\n    end: () => endBuffer,\n    copyData,\n    copyDone: () => copyDoneBuffer,\n    copyFail,\n    cancel\n};\n\nexport { serialize };\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\index.ts",{"fileContent":"import { /*BackendMessage,*/ DatabaseError } from './messages';\nimport { serialize } from './serializer';\nimport { Parser, MessageCallback } from './parser';\n\nexport function parse(stream: NodeJS.ReadableStream, callback: MessageCallback): Promise<void> {\n    const parser = new Parser();\n    stream.on('data', (buffer: Buffer) => parser.parse(buffer, callback));\n\n    // only when the message \"ends\" ( a message boundery? ) so this kinda makes sense, sure\n    return new Promise((resolve) => stream.on('end', () => resolve()));\n}\n\nexport { serialize, DatabaseError };\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\inbound-parser.test.ts",{"fileContent":"import buffers from './testing/test-buffers';\nimport BufferList from './testing/buffer-list';\nimport { parse } from '.';\n\nimport { PassThrough } from 'stream';\nimport { BackendMessage } from './messages';\n\nvar authOkBuffer = buffers.authenticationOk();\nvar paramStatusBuffer = buffers.parameterStatus('client_encoding', 'UTF8');\nvar readyForQueryBuffer = buffers.readyForQuery();\nvar backendKeyDataBuffer = buffers.backendKeyData(1, 2);\nvar commandCompleteBuffer = buffers.commandComplete('SELECT 3');\nvar parseCompleteBuffer = buffers.parseComplete();\nvar bindCompleteBuffer = buffers.bindComplete();\nvar portalSuspendedBuffer = buffers.portalSuspended();\n\n/*var addRow = function (bufferList: BufferList, name: string, offset: number) {\n    return bufferList\n        .addCString(name) // field name\n        .addInt32(offset++) // table id\n        .addInt16(offset++) // attribute of column number\n        .addInt32(offset++) // objectId of field's data type\n        .addInt16(offset++) // datatype size\n        .addInt32(offset++) // type modifier\n        .addInt16(0); // format code, 0 => text\n};\n*/\nvar row1 = {\n    name: 'id',\n    tableID: 1,\n    attributeNumber: 2,\n    dataTypeID: 3,\n    dataTypeSize: 4,\n    typeModifier: 5,\n    formatCode: 0\n};\nvar oneRowDescBuff = buffers.rowDescription([row1]);\nrow1.name = 'bang';\n\nvar twoRowBuf = buffers.rowDescription([\n    row1,\n    {\n        name: 'whoah',\n        tableID: 10,\n        attributeNumber: 11,\n        dataTypeID: 12,\n        dataTypeSize: 13,\n        typeModifier: 14,\n        formatCode: 0\n    }\n]);\n\nvar emptyRowFieldBuf = new BufferList().addInt16(0).join(true, 'D');\n\nvar emptyRowFieldBuf = buffers.dataRow([]);\n\nvar oneFieldBuf = new BufferList()\n    .addInt16(1) // number of fields\n    .addInt32(5) // length of bytes of fields\n    .addCString('test')\n    .join(true, 'D');\n\nvar oneFieldBuf = buffers.dataRow(['test']);\n\nvar expectedAuthenticationOkayMessage = {\n    name: 'authenticationOk',\n    length: 8\n};\n\nvar expectedParameterStatusMessage = {\n    name: 'parameterStatus',\n    parameterName: 'client_encoding',\n    parameterValue: 'UTF8',\n    length: 25\n};\n\nvar expectedBackendKeyDataMessage = {\n    name: 'backendKeyData',\n    processID: 1,\n    secretKey: 2\n};\n\nvar expectedReadyForQueryMessage = {\n    name: 'readyForQuery',\n    length: 5,\n    status: 'I'\n};\n\nvar expectedCommandCompleteMessage = {\n    name: 'commandComplete',\n    length: 13,\n    text: 'SELECT 3'\n};\nvar emptyRowDescriptionBuffer = new BufferList()\n    .addInt16(0) // number of fields\n    .join(true, 'T');\n\nvar expectedEmptyRowDescriptionMessage = {\n    name: 'rowDescription',\n    length: 6,\n    fieldCount: 0,\n    fields: []\n};\nvar expectedOneRowMessage = {\n    name: 'rowDescription',\n    length: 27,\n    fieldCount: 1,\n    fields: [\n        {\n            name: 'id',\n            tableID: 1,\n            columnID: 2,\n            dataTypeID: 3,\n            dataTypeSize: 4,\n            dataTypeModifier: 5,\n            format: 'text'\n        }\n    ]\n};\n\nvar expectedTwoRowMessage = {\n    name: 'rowDescription',\n    length: 53,\n    fieldCount: 2,\n    fields: [\n        {\n            name: 'bang',\n            tableID: 1,\n            columnID: 2,\n            dataTypeID: 3,\n            dataTypeSize: 4,\n            dataTypeModifier: 5,\n            format: 'text'\n        },\n        {\n            name: 'whoah',\n            tableID: 10,\n            columnID: 11,\n            dataTypeID: 12,\n            dataTypeSize: 13,\n            dataTypeModifier: 14,\n            format: 'text'\n        }\n    ]\n};\n\nvar emptyParameterDescriptionBuffer = new BufferList()\n    .addInt16(0) // number of parameters\n    .join(true, 't');\n\nvar oneParameterDescBuf = buffers.parameterDescription([1111]);\n\nvar twoParameterDescBuf = buffers.parameterDescription([2222, 3333]);\n\nvar expectedEmptyParameterDescriptionMessage = {\n    name: 'parameterDescription',\n    length: 6,\n    parameterCount: 0,\n    dataTypeIDs: []\n};\n\nvar expectedOneParameterMessage = {\n    name: 'parameterDescription',\n    length: 10,\n    parameterCount: 1,\n    dataTypeIDs: [1111]\n};\n\nvar expectedTwoParameterMessage = {\n    name: 'parameterDescription',\n    length: 14,\n    parameterCount: 2,\n    dataTypeIDs: [2222, 3333]\n};\n\nvar testForMessage = function (buffer: Buffer, expectedMessage: any) {\n    it('recieves and parses ' + expectedMessage.name, async () => {\n        const messages = await parseBuffers([buffer]);\n        const [lastMessage] = messages;\n\n        for (const key in expectedMessage) {\n            expect((lastMessage as any)[key]).toEqual(expectedMessage[key]);\n        }\n    });\n};\n\nvar plainPasswordBuffer = buffers.authenticationCleartextPassword();\nvar md5PasswordBuffer = buffers.authenticationMD5Password();\nvar SASLBuffer = buffers.authenticationSASL();\nvar SASLContinueBuffer = buffers.authenticationSASLContinue();\nvar SASLFinalBuffer = buffers.authenticationSASLFinal();\n\nvar expectedPlainPasswordMessage = {\n    name: 'authenticationCleartextPassword'\n};\n\nvar expectedMD5PasswordMessage = {\n    name: 'authenticationMD5Password',\n    salt: Buffer.from([1, 2, 3, 4])\n};\n\nvar expectedSASLMessage = {\n    name: 'authenticationSASL',\n    mechanisms: ['SCRAM-SHA-256']\n};\n\nvar expectedSASLContinueMessage = {\n    name: 'authenticationSASLContinue',\n    data: 'data'\n};\n\nvar expectedSASLFinalMessage = {\n    name: 'authenticationSASLFinal',\n    data: 'data'\n};\n\nvar notificationResponseBuffer = buffers.notification(4, 'hi', 'boom');\nvar expectedNotificationResponseMessage = {\n    name: 'notification',\n    processId: 4,\n    channel: 'hi',\n    payload: 'boom'\n};\n\nconst parseBuffers = async (buffers: Buffer[]): Promise<BackendMessage[]> => {\n    const stream = new PassThrough();\n    for (const buffer of buffers) {\n        stream.write(buffer);\n    }\n    stream.end();\n    const msgs: BackendMessage[] = [];\n    await parse(stream, (msg) => msgs.push(msg));\n    return msgs;\n};\n\ndescribe('PgPacketStream', function () {\n    testForMessage(authOkBuffer, expectedAuthenticationOkayMessage);\n    testForMessage(plainPasswordBuffer, expectedPlainPasswordMessage);\n    testForMessage(md5PasswordBuffer, expectedMD5PasswordMessage);\n    testForMessage(SASLBuffer, expectedSASLMessage);\n    testForMessage(SASLContinueBuffer, expectedSASLContinueMessage);\n\n    // this exercises a found bug in the parser:\n    // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084\n    // and adds a test which is deterministic, rather than relying on network packet chunking\n    const extendedSASLContinueBuffer = Buffer.concat([SASLContinueBuffer, Buffer.from([1, 2, 3, 4])]);\n    testForMessage(extendedSASLContinueBuffer, expectedSASLContinueMessage);\n\n    testForMessage(SASLFinalBuffer, expectedSASLFinalMessage);\n\n    // this exercises a found bug in the parser:\n    // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084\n    // and adds a test which is deterministic, rather than relying on network packet chunking\n    const extendedSASLFinalBuffer = Buffer.concat([SASLFinalBuffer, Buffer.from([1, 2, 4, 5])]);\n    testForMessage(extendedSASLFinalBuffer, expectedSASLFinalMessage);\n\n    testForMessage(paramStatusBuffer, expectedParameterStatusMessage);\n    testForMessage(backendKeyDataBuffer, expectedBackendKeyDataMessage);\n    testForMessage(readyForQueryBuffer, expectedReadyForQueryMessage);\n    testForMessage(commandCompleteBuffer, expectedCommandCompleteMessage);\n    testForMessage(notificationResponseBuffer, expectedNotificationResponseMessage);\n    testForMessage(buffers.emptyQuery(), {\n        name: 'emptyQuery',\n        length: 4\n    });\n\n    testForMessage(Buffer.from([0x6e, 0, 0, 0, 4]), {\n        name: 'noData'\n    });\n\n    describe('rowDescription messages', function () {\n        testForMessage(emptyRowDescriptionBuffer, expectedEmptyRowDescriptionMessage);\n        testForMessage(oneRowDescBuff, expectedOneRowMessage);\n        testForMessage(twoRowBuf, expectedTwoRowMessage);\n    });\n\n    describe('parameterDescription messages', function () {\n        testForMessage(emptyParameterDescriptionBuffer, expectedEmptyParameterDescriptionMessage);\n        testForMessage(oneParameterDescBuf, expectedOneParameterMessage);\n        testForMessage(twoParameterDescBuf, expectedTwoParameterMessage);\n    });\n\n    describe('parsing rows', function () {\n        describe('parsing empty row', function () {\n            testForMessage(emptyRowFieldBuf, {\n                name: 'dataRow',\n                fieldCount: 0\n            });\n        });\n\n        describe('parsing data row with fields', function () {\n            testForMessage(oneFieldBuf, {\n                name: 'dataRow',\n                fieldCount: 1,\n                fields: ['test']\n            });\n        });\n    });\n\n    describe('notice message', function () {\n        // this uses the same logic as error message\n        var buff = buffers.notice([{ type: 'C', value: 'code' }]);\n        testForMessage(buff, {\n            name: 'notice',\n            code: 'code'\n        });\n    });\n\n    testForMessage(buffers.error([]), {\n        name: 'error'\n    });\n\n    describe('with all the fields', function () {\n        var buffer = buffers.error([\n            {\n                type: 'S',\n                value: 'ERROR'\n            },\n            {\n                type: 'C',\n                value: 'code'\n            },\n            {\n                type: 'M',\n                value: 'message'\n            },\n            {\n                type: 'D',\n                value: 'details'\n            },\n            {\n                type: 'H',\n                value: 'hint'\n            },\n            {\n                type: 'P',\n                value: '100'\n            },\n            {\n                type: 'p',\n                value: '101'\n            },\n            {\n                type: 'q',\n                value: 'query'\n            },\n            {\n                type: 'W',\n                value: 'where'\n            },\n            {\n                type: 'F',\n                value: 'file'\n            },\n            {\n                type: 'L',\n                value: 'line'\n            },\n            {\n                type: 'R',\n                value: 'routine'\n            },\n            {\n                type: 'Z', // ignored\n                value: 'alsdkf'\n            }\n        ]);\n\n        testForMessage(buffer, {\n            name: 'error',\n            severity: 'ERROR',\n            code: 'code',\n            message: 'message',\n            detail: 'details',\n            hint: 'hint',\n            position: '100',\n            internalPosition: '101',\n            internalQuery: 'query',\n            where: 'where',\n            file: 'file',\n            line: 'line',\n            routine: 'routine'\n        });\n    });\n\n    testForMessage(parseCompleteBuffer, {\n        name: 'parseComplete'\n    });\n\n    testForMessage(bindCompleteBuffer, {\n        name: 'bindComplete'\n    });\n\n    testForMessage(bindCompleteBuffer, {\n        name: 'bindComplete'\n    });\n\n    testForMessage(buffers.closeComplete(), {\n        name: 'closeComplete'\n    });\n\n    describe('parses portal suspended message', function () {\n        testForMessage(portalSuspendedBuffer, {\n            name: 'portalSuspended'\n        });\n    });\n\n    describe('parses replication start message', function () {\n        testForMessage(Buffer.from([0x57, 0x00, 0x00, 0x00, 0x04]), {\n            name: 'replicationStart',\n            length: 4\n        });\n    });\n\n    describe('copy', () => {\n        testForMessage(buffers.copyIn(0), {\n            name: 'copyInResponse',\n            length: 7,\n            binary: false,\n            columnTypes: []\n        });\n\n        testForMessage(buffers.copyIn(2), {\n            name: 'copyInResponse',\n            length: 11,\n            binary: false,\n            columnTypes: [0, 1]\n        });\n\n        testForMessage(buffers.copyOut(0), {\n            name: 'copyOutResponse',\n            length: 7,\n            binary: false,\n            columnTypes: []\n        });\n\n        testForMessage(buffers.copyOut(3), {\n            name: 'copyOutResponse',\n            length: 13,\n            binary: false,\n            columnTypes: [0, 1, 2]\n        });\n\n        testForMessage(buffers.copyDone(), {\n            name: 'copyDone',\n            length: 4\n        });\n\n        testForMessage(buffers.copyData(Buffer.from([5, 6, 7])), {\n            name: 'copyData',\n            length: 7,\n            chunk: Buffer.from([5, 6, 7])\n        });\n    });\n\n    // since the data message on a stream can randomly divide the incomming\n    // tcp packets anywhere, we need to make sure we can parse every single\n    // split on a tcp message\n    describe('split buffer, single message parsing', function () {\n        var fullBuffer = buffers.dataRow([null, 'bang', 'zug zug', null, '!']);\n\n        it('parses when full buffer comes in', async function () {\n            const messages = await parseBuffers([fullBuffer]);\n            const message = messages[0] as any;\n            expect(message.fields.length).toBe(5);\n            expect(message.fields[0]).toBeNull();\n            expect(message.fields[1]).toBe('bang');\n            expect(message.fields[2]).toBe('zug zug');\n            expect(message.fields[3]).toBeNull();\n            expect(message.fields[4]).toBe('!');\n        });\n\n        var testMessageRecievedAfterSpiltAt = async function (split: number) {\n            var firstBuffer = Buffer.alloc(fullBuffer.length - split);\n            var secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length);\n            fullBuffer.copy(firstBuffer, 0, 0);\n            fullBuffer.copy(secondBuffer, 0, firstBuffer.length);\n            const messages = await parseBuffers([fullBuffer]);\n            const message = messages[0] as any;\n            expect(message.fields.length).toBe(5);\n            expect(message.fields[0]).toBe(null);\n            expect(message.fields[1]).toBe('bang');\n            expect(message.fields[2]).toBe('zug zug');\n            expect(message.fields[3]).toBe(null);\n            expect(message.fields[4]).toBe('!');\n        };\n\n        it('parses when split in the middle', function () {\n            testMessageRecievedAfterSpiltAt(6);\n        });\n\n        it('parses when split at end', function () {\n            testMessageRecievedAfterSpiltAt(2);\n        });\n\n        it('parses when split at beginning', function () {\n            testMessageRecievedAfterSpiltAt(fullBuffer.length - 2);\n            testMessageRecievedAfterSpiltAt(fullBuffer.length - 1);\n            testMessageRecievedAfterSpiltAt(fullBuffer.length - 5);\n        });\n    });\n\n    describe('split buffer, multiple message parsing', function () {\n        var dataRowBuffer = buffers.dataRow(['!']);\n        var readyForQueryBuffer = buffers.readyForQuery();\n        var fullBuffer = Buffer.alloc(dataRowBuffer.length + readyForQueryBuffer.length);\n        dataRowBuffer.copy(fullBuffer, 0, 0);\n        readyForQueryBuffer.copy(fullBuffer, dataRowBuffer.length, 0);\n\n        var verifyMessages = function (messages: any[]) {\n            expect(messages.length).toBe(2);\n            expect(messages[0]).toEqual({\n                name: 'dataRow',\n                fieldCount: 1,\n                length: 11,\n                fields: ['!']\n            });\n            expect(messages[0].fields[0]).toBe('!');\n            expect(messages[1]).toEqual({\n                name: 'readyForQuery',\n                length: 5,\n                status: 'I'\n            });\n        };\n        // sanity check\n        it('recieves both messages when packet is not split', async function () {\n            const messages = await parseBuffers([fullBuffer]);\n            verifyMessages(messages);\n        });\n\n        var splitAndVerifyTwoMessages = async function (split: number) {\n            var firstBuffer = Buffer.alloc(fullBuffer.length - split);\n            var secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length);\n            fullBuffer.copy(firstBuffer, 0, 0);\n            fullBuffer.copy(secondBuffer, 0, firstBuffer.length);\n            const messages = await parseBuffers([firstBuffer, secondBuffer]);\n            verifyMessages(messages);\n        };\n\n        describe('recieves both messages when packet is split', function () {\n            it('in the middle', function () {\n                return splitAndVerifyTwoMessages(11);\n            });\n            it('at the front', function () {\n                return Promise.all([\n                    splitAndVerifyTwoMessages(fullBuffer.length - 1),\n                    splitAndVerifyTwoMessages(fullBuffer.length - 4),\n                    splitAndVerifyTwoMessages(fullBuffer.length - 6)\n                ]);\n            });\n\n            it('at the end', function () {\n                return Promise.all([splitAndVerifyTwoMessages(8), splitAndVerifyTwoMessages(1)]);\n            });\n        });\n    });\n});\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/testing/test-buffers.ts","C:/repos/node-postgres/packages/pg-protocol/src/testing/buffer-list.ts","C:/repos/node-postgres/packages/pg-protocol/src/index.ts","C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\buffer-reader.ts",{"fileContent":"const emptyBuffer = Buffer.allocUnsafe(0);\n\nexport class BufferReader {\n    private buffer: Buffer = emptyBuffer;\n\n    // TODO(bmc): support non-utf8 encoding?\n    private encoding: string = 'utf-8';\n\n    constructor(private offset: number = 0) {}\n\n    public setBuffer(offset: number, buffer: Buffer): void {\n        this.offset = offset;\n        this.buffer = buffer;\n    }\n\n    public int16(): number {\n        const result = this.buffer.readInt16BE(this.offset);\n        this.offset += 2;\n        return result;\n    }\n\n    public byte(): number {\n        const result = this.buffer[this.offset];\n        this.offset++;\n        return result;\n    }\n\n    public int32(): number {\n        const result = this.buffer.readInt32BE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n\n    public string(length: number): string {\n        const encoding = this.encoding;\n        //@ts-ignore\n        const result = this.buffer.toString(encoding, this.offset, this.offset + length);\n        this.offset += length;\n        return result;\n    }\n\n    public cstring(): string {\n        const start = this.offset;\n        let end = start;\n        while (this.buffer[end++] !== 0) {}\n        this.offset = end;\n        //@ts-ignore\n        return this.buffer.toString(this.encoding, start, end - 1);\n    }\n\n    public bytes(length: number): Buffer {\n        const result = this.buffer.slice(this.offset, this.offset + length);\n        this.offset += length;\n        return result;\n    }\n}\n","resolvedModuleNames":[]}]]