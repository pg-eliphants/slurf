[["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\testing\\test-buffers.ts",{"fileContent":"// https://www.postgresql.org/docs/current/protocol-message-formats.html\r\nimport BufferList from './buffer-list'\r\n\r\nconst buffers = {\r\n  readyForQuery: function () {\r\n    return new BufferList().add(Buffer.from('I')).join(true, 'Z')\r\n  },\r\n\r\n  authenticationOk: function () {\r\n    return new BufferList().addInt32(0).join(true, 'R')\r\n  },\r\n\r\n  authenticationCleartextPassword: function () {\r\n    return new BufferList().addInt32(3).join(true, 'R')\r\n  },\r\n\r\n  authenticationMD5Password: function () {\r\n    return new BufferList()\r\n      .addInt32(5)\r\n      .add(Buffer.from([1, 2, 3, 4]))\r\n      .join(true, 'R')\r\n  },\r\n\r\n  authenticationSASL: function () {\r\n    return new BufferList().addInt32(10).addCString('SCRAM-SHA-256').addCString('').join(true, 'R')\r\n  },\r\n\r\n  authenticationSASLContinue: function () {\r\n    return new BufferList().addInt32(11).addString('data').join(true, 'R')\r\n  },\r\n\r\n  authenticationSASLFinal: function () {\r\n    return new BufferList().addInt32(12).addString('data').join(true, 'R')\r\n  },\r\n\r\n  parameterStatus: function (name: string, value: string) {\r\n    return new BufferList().addCString(name).addCString(value).join(true, 'S')\r\n  },\r\n\r\n  backendKeyData: function (processID: number, secretKey: number) {\r\n    return new BufferList().addInt32(processID).addInt32(secretKey).join(true, 'K')\r\n  },\r\n\r\n  commandComplete: function (string: string) {\r\n    return new BufferList().addCString(string).join(true, 'C')\r\n  },\r\n\r\n  rowDescription: function (fields: any[]) {\r\n    fields = fields || []\r\n    var buf = new BufferList()\r\n    buf.addInt16(fields.length)\r\n    fields.forEach(function (field) {\r\n      buf\r\n        .addCString(field.name)\r\n        .addInt32(field.tableID || 0)\r\n        .addInt16(field.attributeNumber || 0)\r\n        .addInt32(field.dataTypeID || 0)\r\n        .addInt16(field.dataTypeSize || 0)\r\n        .addInt32(field.typeModifier || 0)\r\n        .addInt16(field.formatCode || 0)\r\n    })\r\n    return buf.join(true, 'T')\r\n  },\r\n\r\n  parameterDescription: function (dataTypeIDs: number[]) {\r\n    dataTypeIDs = dataTypeIDs || []\r\n    var buf = new BufferList()\r\n    buf.addInt16(dataTypeIDs.length)\r\n    dataTypeIDs.forEach(function (dataTypeID) {\r\n      buf.addInt32(dataTypeID)\r\n    })\r\n    return buf.join(true, 't')\r\n  },\r\n\r\n  dataRow: function (columns: any[]) {\r\n    columns = columns || []\r\n    var buf = new BufferList()\r\n    buf.addInt16(columns.length)\r\n    columns.forEach(function (col) {\r\n      if (col == null) {\r\n        buf.addInt32(-1)\r\n      } else {\r\n        var strBuf = Buffer.from(col, 'utf8')\r\n        buf.addInt32(strBuf.length)\r\n        buf.add(strBuf)\r\n      }\r\n    })\r\n    return buf.join(true, 'D')\r\n  },\r\n\r\n  error: function (fields: any) {\r\n    return buffers.errorOrNotice(fields).join(true, 'E')\r\n  },\r\n\r\n  notice: function (fields: any) {\r\n    return buffers.errorOrNotice(fields).join(true, 'N')\r\n  },\r\n\r\n  errorOrNotice: function (fields: any) {\r\n    fields = fields || []\r\n    var buf = new BufferList()\r\n    fields.forEach(function (field: any) {\r\n      buf.addChar(field.type)\r\n      buf.addCString(field.value)\r\n    })\r\n    return buf.add(Buffer.from([0])) // terminator\r\n  },\r\n\r\n  parseComplete: function () {\r\n    return new BufferList().join(true, '1')\r\n  },\r\n\r\n  bindComplete: function () {\r\n    return new BufferList().join(true, '2')\r\n  },\r\n\r\n  notification: function (id: number, channel: string, payload: string) {\r\n    return new BufferList().addInt32(id).addCString(channel).addCString(payload).join(true, 'A')\r\n  },\r\n\r\n  emptyQuery: function () {\r\n    return new BufferList().join(true, 'I')\r\n  },\r\n\r\n  portalSuspended: function () {\r\n    return new BufferList().join(true, 's')\r\n  },\r\n\r\n  closeComplete: function () {\r\n    return new BufferList().join(true, '3')\r\n  },\r\n\r\n  copyIn: function (cols: number) {\r\n    const list = new BufferList()\r\n      // text mode\r\n      .addByte(0)\r\n      // column count\r\n      .addInt16(cols)\r\n    for (let i = 0; i < cols; i++) {\r\n      list.addInt16(i)\r\n    }\r\n    return list.join(true, 'G')\r\n  },\r\n\r\n  copyOut: function (cols: number) {\r\n    const list = new BufferList()\r\n      // text mode\r\n      .addByte(0)\r\n      // column count\r\n      .addInt16(cols)\r\n    for (let i = 0; i < cols; i++) {\r\n      list.addInt16(i)\r\n    }\r\n    return list.join(true, 'H')\r\n  },\r\n\r\n  copyData: function (bytes: Buffer) {\r\n    return new BufferList().add(bytes).join(true, 'd')\r\n  },\r\n\r\n  copyDone: function () {\r\n    return new BufferList().join(true, 'c')\r\n  },\r\n}\r\n\r\nexport default buffers\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/testing/buffer-list.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\testing\\buffer-list.ts",{"fileContent":"export default class BufferList {\r\n  constructor(public buffers: Buffer[] = []) {}\r\n\r\n  public add(buffer: Buffer, front?: boolean) {\r\n    this.buffers[front ? 'unshift' : 'push'](buffer)\r\n    return this\r\n  }\r\n\r\n  public addInt16(val: number, front?: boolean) {\r\n    return this.add(Buffer.from([val >>> 8, val >>> 0]), front)\r\n  }\r\n\r\n  public getByteLength(initial?: number) {\r\n    return this.buffers.reduce(function (previous, current) {\r\n      return previous + current.length\r\n    }, initial || 0)\r\n  }\r\n\r\n  public addInt32(val: number, first?: boolean) {\r\n    return this.add(\r\n      Buffer.from([(val >>> 24) & 0xff, (val >>> 16) & 0xff, (val >>> 8) & 0xff, (val >>> 0) & 0xff]),\r\n      first\r\n    )\r\n  }\r\n\r\n  public addCString(val: string, front?: boolean) {\r\n    var len = Buffer.byteLength(val)\r\n    var buffer = Buffer.alloc(len + 1)\r\n    buffer.write(val)\r\n    buffer[len] = 0\r\n    return this.add(buffer, front)\r\n  }\r\n\r\n  public addString(val: string, front?: boolean) {\r\n    var len = Buffer.byteLength(val)\r\n    var buffer = Buffer.alloc(len)\r\n    buffer.write(val)\r\n    return this.add(buffer, front)\r\n  }\r\n\r\n  public addChar(char: string, first?: boolean) {\r\n    return this.add(Buffer.from(char, 'utf8'), first)\r\n  }\r\n\r\n  public addByte(byte: number) {\r\n    return this.add(Buffer.from([byte]))\r\n  }\r\n\r\n  public join(appendLength?: boolean, char?: string): Buffer {\r\n    var length = this.getByteLength()\r\n    if (appendLength) {\r\n      this.addInt32(length + 4, true)\r\n      return this.join(false, char)\r\n    }\r\n    if (char) {\r\n      this.addChar(char, true)\r\n      length++\r\n    }\r\n    var result = Buffer.alloc(length)\r\n    var index = 0\r\n    this.buffers.forEach(function (buffer) {\r\n      buffer.copy(result, index, 0)\r\n      index += buffer.length\r\n    })\r\n    return result\r\n  }\r\n\r\n  public static concat(): Buffer {\r\n    var total = new BufferList()\r\n    for (var i = 0; i < arguments.length; i++) {\r\n      total.add(arguments[i])\r\n    }\r\n    return total.join()\r\n  }\r\n}\r\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\inbound-parser.test.ts",{"fileContent":"import buffers from './testing/test-buffers'\r\nimport BufferList from './testing/buffer-list'\r\nimport { parse } from '.'\r\nimport assert from 'assert'\r\nimport { PassThrough } from 'stream'\r\nimport { BackendMessage } from './messages'\r\n\r\nvar authOkBuffer = buffers.authenticationOk()\r\nvar paramStatusBuffer = buffers.parameterStatus('client_encoding', 'UTF8')\r\nvar readyForQueryBuffer = buffers.readyForQuery()\r\nvar backendKeyDataBuffer = buffers.backendKeyData(1, 2)\r\nvar commandCompleteBuffer = buffers.commandComplete('SELECT 3')\r\nvar parseCompleteBuffer = buffers.parseComplete()\r\nvar bindCompleteBuffer = buffers.bindComplete()\r\nvar portalSuspendedBuffer = buffers.portalSuspended()\r\n\r\nvar addRow = function (bufferList: BufferList, name: string, offset: number) {\r\n  return bufferList\r\n    .addCString(name) // field name\r\n    .addInt32(offset++) // table id\r\n    .addInt16(offset++) // attribute of column number\r\n    .addInt32(offset++) // objectId of field's data type\r\n    .addInt16(offset++) // datatype size\r\n    .addInt32(offset++) // type modifier\r\n    .addInt16(0) // format code, 0 => text\r\n}\r\n\r\nvar row1 = {\r\n  name: 'id',\r\n  tableID: 1,\r\n  attributeNumber: 2,\r\n  dataTypeID: 3,\r\n  dataTypeSize: 4,\r\n  typeModifier: 5,\r\n  formatCode: 0,\r\n}\r\nvar oneRowDescBuff = buffers.rowDescription([row1])\r\nrow1.name = 'bang'\r\n\r\nvar twoRowBuf = buffers.rowDescription([\r\n  row1,\r\n  {\r\n    name: 'whoah',\r\n    tableID: 10,\r\n    attributeNumber: 11,\r\n    dataTypeID: 12,\r\n    dataTypeSize: 13,\r\n    typeModifier: 14,\r\n    formatCode: 0,\r\n  },\r\n])\r\n\r\nvar emptyRowFieldBuf = new BufferList().addInt16(0).join(true, 'D')\r\n\r\nvar emptyRowFieldBuf = buffers.dataRow([])\r\n\r\nvar oneFieldBuf = new BufferList()\r\n  .addInt16(1) // number of fields\r\n  .addInt32(5) // length of bytes of fields\r\n  .addCString('test')\r\n  .join(true, 'D')\r\n\r\nvar oneFieldBuf = buffers.dataRow(['test'])\r\n\r\nvar expectedAuthenticationOkayMessage = {\r\n  name: 'authenticationOk',\r\n  length: 8,\r\n}\r\n\r\nvar expectedParameterStatusMessage = {\r\n  name: 'parameterStatus',\r\n  parameterName: 'client_encoding',\r\n  parameterValue: 'UTF8',\r\n  length: 25,\r\n}\r\n\r\nvar expectedBackendKeyDataMessage = {\r\n  name: 'backendKeyData',\r\n  processID: 1,\r\n  secretKey: 2,\r\n}\r\n\r\nvar expectedReadyForQueryMessage = {\r\n  name: 'readyForQuery',\r\n  length: 5,\r\n  status: 'I',\r\n}\r\n\r\nvar expectedCommandCompleteMessage = {\r\n  name: 'commandComplete',\r\n  length: 13,\r\n  text: 'SELECT 3',\r\n}\r\nvar emptyRowDescriptionBuffer = new BufferList()\r\n  .addInt16(0) // number of fields\r\n  .join(true, 'T')\r\n\r\nvar expectedEmptyRowDescriptionMessage = {\r\n  name: 'rowDescription',\r\n  length: 6,\r\n  fieldCount: 0,\r\n  fields: [],\r\n}\r\nvar expectedOneRowMessage = {\r\n  name: 'rowDescription',\r\n  length: 27,\r\n  fieldCount: 1,\r\n  fields: [\r\n    {\r\n      name: 'id',\r\n      tableID: 1,\r\n      columnID: 2,\r\n      dataTypeID: 3,\r\n      dataTypeSize: 4,\r\n      dataTypeModifier: 5,\r\n      format: 'text',\r\n    },\r\n  ],\r\n}\r\n\r\nvar expectedTwoRowMessage = {\r\n  name: 'rowDescription',\r\n  length: 53,\r\n  fieldCount: 2,\r\n  fields: [\r\n    {\r\n      name: 'bang',\r\n      tableID: 1,\r\n      columnID: 2,\r\n      dataTypeID: 3,\r\n      dataTypeSize: 4,\r\n      dataTypeModifier: 5,\r\n      format: 'text',\r\n    },\r\n    {\r\n      name: 'whoah',\r\n      tableID: 10,\r\n      columnID: 11,\r\n      dataTypeID: 12,\r\n      dataTypeSize: 13,\r\n      dataTypeModifier: 14,\r\n      format: 'text',\r\n    },\r\n  ],\r\n}\r\n\r\nvar emptyParameterDescriptionBuffer = new BufferList()\r\n  .addInt16(0) // number of parameters\r\n  .join(true, 't')\r\n\r\nvar oneParameterDescBuf = buffers.parameterDescription([1111])\r\n\r\nvar twoParameterDescBuf = buffers.parameterDescription([2222, 3333])\r\n\r\nvar expectedEmptyParameterDescriptionMessage = {\r\n  name: 'parameterDescription',\r\n  length: 6,\r\n  parameterCount: 0,\r\n  dataTypeIDs: [],\r\n}\r\n\r\nvar expectedOneParameterMessage = {\r\n  name: 'parameterDescription',\r\n  length: 10,\r\n  parameterCount: 1,\r\n  dataTypeIDs: [1111],\r\n}\r\n\r\nvar expectedTwoParameterMessage = {\r\n  name: 'parameterDescription',\r\n  length: 14,\r\n  parameterCount: 2,\r\n  dataTypeIDs: [2222, 3333],\r\n}\r\n\r\nvar testForMessage = function (buffer: Buffer, expectedMessage: any) {\r\n  it('recieves and parses ' + expectedMessage.name, async () => {\r\n    const messages = await parseBuffers([buffer])\r\n    const [lastMessage] = messages\r\n\r\n    for (const key in expectedMessage) {\r\n      assert.deepEqual((lastMessage as any)[key], expectedMessage[key])\r\n    }\r\n  })\r\n}\r\n\r\nvar plainPasswordBuffer = buffers.authenticationCleartextPassword()\r\nvar md5PasswordBuffer = buffers.authenticationMD5Password()\r\nvar SASLBuffer = buffers.authenticationSASL()\r\nvar SASLContinueBuffer = buffers.authenticationSASLContinue()\r\nvar SASLFinalBuffer = buffers.authenticationSASLFinal()\r\n\r\nvar expectedPlainPasswordMessage = {\r\n  name: 'authenticationCleartextPassword',\r\n}\r\n\r\nvar expectedMD5PasswordMessage = {\r\n  name: 'authenticationMD5Password',\r\n  salt: Buffer.from([1, 2, 3, 4]),\r\n}\r\n\r\nvar expectedSASLMessage = {\r\n  name: 'authenticationSASL',\r\n  mechanisms: ['SCRAM-SHA-256'],\r\n}\r\n\r\nvar expectedSASLContinueMessage = {\r\n  name: 'authenticationSASLContinue',\r\n  data: 'data',\r\n}\r\n\r\nvar expectedSASLFinalMessage = {\r\n  name: 'authenticationSASLFinal',\r\n  data: 'data',\r\n}\r\n\r\nvar notificationResponseBuffer = buffers.notification(4, 'hi', 'boom')\r\nvar expectedNotificationResponseMessage = {\r\n  name: 'notification',\r\n  processId: 4,\r\n  channel: 'hi',\r\n  payload: 'boom',\r\n}\r\n\r\nconst parseBuffers = async (buffers: Buffer[]): Promise<BackendMessage[]> => {\r\n  const stream = new PassThrough()\r\n  for (const buffer of buffers) {\r\n    stream.write(buffer)\r\n  }\r\n  stream.end()\r\n  const msgs: BackendMessage[] = []\r\n  await parse(stream, (msg) => msgs.push(msg))\r\n  return msgs\r\n}\r\n\r\ndescribe('PgPacketStream', function () {\r\n  testForMessage(authOkBuffer, expectedAuthenticationOkayMessage)\r\n  testForMessage(plainPasswordBuffer, expectedPlainPasswordMessage)\r\n  testForMessage(md5PasswordBuffer, expectedMD5PasswordMessage)\r\n  testForMessage(SASLBuffer, expectedSASLMessage)\r\n  testForMessage(SASLContinueBuffer, expectedSASLContinueMessage)\r\n\r\n  // this exercises a found bug in the parser:\r\n  // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084\r\n  // and adds a test which is deterministic, rather than relying on network packet chunking\r\n  const extendedSASLContinueBuffer = Buffer.concat([SASLContinueBuffer, Buffer.from([1, 2, 3, 4])])\r\n  testForMessage(extendedSASLContinueBuffer, expectedSASLContinueMessage)\r\n\r\n  testForMessage(SASLFinalBuffer, expectedSASLFinalMessage)\r\n\r\n  // this exercises a found bug in the parser:\r\n  // https://github.com/brianc/node-postgres/pull/2210#issuecomment-627626084\r\n  // and adds a test which is deterministic, rather than relying on network packet chunking\r\n  const extendedSASLFinalBuffer = Buffer.concat([SASLFinalBuffer, Buffer.from([1, 2, 4, 5])])\r\n  testForMessage(extendedSASLFinalBuffer, expectedSASLFinalMessage)\r\n\r\n  testForMessage(paramStatusBuffer, expectedParameterStatusMessage)\r\n  testForMessage(backendKeyDataBuffer, expectedBackendKeyDataMessage)\r\n  testForMessage(readyForQueryBuffer, expectedReadyForQueryMessage)\r\n  testForMessage(commandCompleteBuffer, expectedCommandCompleteMessage)\r\n  testForMessage(notificationResponseBuffer, expectedNotificationResponseMessage)\r\n  testForMessage(buffers.emptyQuery(), {\r\n    name: 'emptyQuery',\r\n    length: 4,\r\n  })\r\n\r\n  testForMessage(Buffer.from([0x6e, 0, 0, 0, 4]), {\r\n    name: 'noData',\r\n  })\r\n\r\n  describe('rowDescription messages', function () {\r\n    testForMessage(emptyRowDescriptionBuffer, expectedEmptyRowDescriptionMessage)\r\n    testForMessage(oneRowDescBuff, expectedOneRowMessage)\r\n    testForMessage(twoRowBuf, expectedTwoRowMessage)\r\n  })\r\n\r\n  describe('parameterDescription messages', function () {\r\n    testForMessage(emptyParameterDescriptionBuffer, expectedEmptyParameterDescriptionMessage)\r\n    testForMessage(oneParameterDescBuf, expectedOneParameterMessage)\r\n    testForMessage(twoParameterDescBuf, expectedTwoParameterMessage)\r\n  })\r\n\r\n  describe('parsing rows', function () {\r\n    describe('parsing empty row', function () {\r\n      testForMessage(emptyRowFieldBuf, {\r\n        name: 'dataRow',\r\n        fieldCount: 0,\r\n      })\r\n    })\r\n\r\n    describe('parsing data row with fields', function () {\r\n      testForMessage(oneFieldBuf, {\r\n        name: 'dataRow',\r\n        fieldCount: 1,\r\n        fields: ['test'],\r\n      })\r\n    })\r\n  })\r\n\r\n  describe('notice message', function () {\r\n    // this uses the same logic as error message\r\n    var buff = buffers.notice([{ type: 'C', value: 'code' }])\r\n    testForMessage(buff, {\r\n      name: 'notice',\r\n      code: 'code',\r\n    })\r\n  })\r\n\r\n  testForMessage(buffers.error([]), {\r\n    name: 'error',\r\n  })\r\n\r\n  describe('with all the fields', function () {\r\n    var buffer = buffers.error([\r\n      {\r\n        type: 'S',\r\n        value: 'ERROR',\r\n      },\r\n      {\r\n        type: 'C',\r\n        value: 'code',\r\n      },\r\n      {\r\n        type: 'M',\r\n        value: 'message',\r\n      },\r\n      {\r\n        type: 'D',\r\n        value: 'details',\r\n      },\r\n      {\r\n        type: 'H',\r\n        value: 'hint',\r\n      },\r\n      {\r\n        type: 'P',\r\n        value: '100',\r\n      },\r\n      {\r\n        type: 'p',\r\n        value: '101',\r\n      },\r\n      {\r\n        type: 'q',\r\n        value: 'query',\r\n      },\r\n      {\r\n        type: 'W',\r\n        value: 'where',\r\n      },\r\n      {\r\n        type: 'F',\r\n        value: 'file',\r\n      },\r\n      {\r\n        type: 'L',\r\n        value: 'line',\r\n      },\r\n      {\r\n        type: 'R',\r\n        value: 'routine',\r\n      },\r\n      {\r\n        type: 'Z', // ignored\r\n        value: 'alsdkf',\r\n      },\r\n    ])\r\n\r\n    testForMessage(buffer, {\r\n      name: 'error',\r\n      severity: 'ERROR',\r\n      code: 'code',\r\n      message: 'message',\r\n      detail: 'details',\r\n      hint: 'hint',\r\n      position: '100',\r\n      internalPosition: '101',\r\n      internalQuery: 'query',\r\n      where: 'where',\r\n      file: 'file',\r\n      line: 'line',\r\n      routine: 'routine',\r\n    })\r\n  })\r\n\r\n  testForMessage(parseCompleteBuffer, {\r\n    name: 'parseComplete',\r\n  })\r\n\r\n  testForMessage(bindCompleteBuffer, {\r\n    name: 'bindComplete',\r\n  })\r\n\r\n  testForMessage(bindCompleteBuffer, {\r\n    name: 'bindComplete',\r\n  })\r\n\r\n  testForMessage(buffers.closeComplete(), {\r\n    name: 'closeComplete',\r\n  })\r\n\r\n  describe('parses portal suspended message', function () {\r\n    testForMessage(portalSuspendedBuffer, {\r\n      name: 'portalSuspended',\r\n    })\r\n  })\r\n\r\n  describe('parses replication start message', function () {\r\n    testForMessage(Buffer.from([0x57, 0x00, 0x00, 0x00, 0x04]), {\r\n      name: 'replicationStart',\r\n      length: 4,\r\n    })\r\n  })\r\n\r\n  describe('copy', () => {\r\n    testForMessage(buffers.copyIn(0), {\r\n      name: 'copyInResponse',\r\n      length: 7,\r\n      binary: false,\r\n      columnTypes: [],\r\n    })\r\n\r\n    testForMessage(buffers.copyIn(2), {\r\n      name: 'copyInResponse',\r\n      length: 11,\r\n      binary: false,\r\n      columnTypes: [0, 1],\r\n    })\r\n\r\n    testForMessage(buffers.copyOut(0), {\r\n      name: 'copyOutResponse',\r\n      length: 7,\r\n      binary: false,\r\n      columnTypes: [],\r\n    })\r\n\r\n    testForMessage(buffers.copyOut(3), {\r\n      name: 'copyOutResponse',\r\n      length: 13,\r\n      binary: false,\r\n      columnTypes: [0, 1, 2],\r\n    })\r\n\r\n    testForMessage(buffers.copyDone(), {\r\n      name: 'copyDone',\r\n      length: 4,\r\n    })\r\n\r\n    testForMessage(buffers.copyData(Buffer.from([5, 6, 7])), {\r\n      name: 'copyData',\r\n      length: 7,\r\n      chunk: Buffer.from([5, 6, 7]),\r\n    })\r\n  })\r\n\r\n  // since the data message on a stream can randomly divide the incomming\r\n  // tcp packets anywhere, we need to make sure we can parse every single\r\n  // split on a tcp message\r\n  describe('split buffer, single message parsing', function () {\r\n    var fullBuffer = buffers.dataRow([null, 'bang', 'zug zug', null, '!'])\r\n\r\n    it('parses when full buffer comes in', async function () {\r\n      const messages = await parseBuffers([fullBuffer])\r\n      const message = messages[0] as any\r\n      assert.equal(message.fields.length, 5)\r\n      assert.equal(message.fields[0], null)\r\n      assert.equal(message.fields[1], 'bang')\r\n      assert.equal(message.fields[2], 'zug zug')\r\n      assert.equal(message.fields[3], null)\r\n      assert.equal(message.fields[4], '!')\r\n    })\r\n\r\n    var testMessageRecievedAfterSpiltAt = async function (split: number) {\r\n      var firstBuffer = Buffer.alloc(fullBuffer.length - split)\r\n      var secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length)\r\n      fullBuffer.copy(firstBuffer, 0, 0)\r\n      fullBuffer.copy(secondBuffer, 0, firstBuffer.length)\r\n      const messages = await parseBuffers([fullBuffer])\r\n      const message = messages[0] as any\r\n      assert.equal(message.fields.length, 5)\r\n      assert.equal(message.fields[0], null)\r\n      assert.equal(message.fields[1], 'bang')\r\n      assert.equal(message.fields[2], 'zug zug')\r\n      assert.equal(message.fields[3], null)\r\n      assert.equal(message.fields[4], '!')\r\n    }\r\n\r\n    it('parses when split in the middle', function () {\r\n      testMessageRecievedAfterSpiltAt(6)\r\n    })\r\n\r\n    it('parses when split at end', function () {\r\n      testMessageRecievedAfterSpiltAt(2)\r\n    })\r\n\r\n    it('parses when split at beginning', function () {\r\n      testMessageRecievedAfterSpiltAt(fullBuffer.length - 2)\r\n      testMessageRecievedAfterSpiltAt(fullBuffer.length - 1)\r\n      testMessageRecievedAfterSpiltAt(fullBuffer.length - 5)\r\n    })\r\n  })\r\n\r\n  describe('split buffer, multiple message parsing', function () {\r\n    var dataRowBuffer = buffers.dataRow(['!'])\r\n    var readyForQueryBuffer = buffers.readyForQuery()\r\n    var fullBuffer = Buffer.alloc(dataRowBuffer.length + readyForQueryBuffer.length)\r\n    dataRowBuffer.copy(fullBuffer, 0, 0)\r\n    readyForQueryBuffer.copy(fullBuffer, dataRowBuffer.length, 0)\r\n\r\n    var verifyMessages = function (messages: any[]) {\r\n      assert.strictEqual(messages.length, 2)\r\n      assert.deepEqual(messages[0], {\r\n        name: 'dataRow',\r\n        fieldCount: 1,\r\n        length: 11,\r\n        fields: ['!'],\r\n      })\r\n      assert.equal(messages[0].fields[0], '!')\r\n      assert.deepEqual(messages[1], {\r\n        name: 'readyForQuery',\r\n        length: 5,\r\n        status: 'I',\r\n      })\r\n    }\r\n    // sanity check\r\n    it('recieves both messages when packet is not split', async function () {\r\n      const messages = await parseBuffers([fullBuffer])\r\n      verifyMessages(messages)\r\n    })\r\n\r\n    var splitAndVerifyTwoMessages = async function (split: number) {\r\n      var firstBuffer = Buffer.alloc(fullBuffer.length - split)\r\n      var secondBuffer = Buffer.alloc(fullBuffer.length - firstBuffer.length)\r\n      fullBuffer.copy(firstBuffer, 0, 0)\r\n      fullBuffer.copy(secondBuffer, 0, firstBuffer.length)\r\n      const messages = await parseBuffers([firstBuffer, secondBuffer])\r\n      verifyMessages(messages)\r\n    }\r\n\r\n    describe('recieves both messages when packet is split', function () {\r\n      it('in the middle', function () {\r\n        return splitAndVerifyTwoMessages(11)\r\n      })\r\n      it('at the front', function () {\r\n        return Promise.all([\r\n          splitAndVerifyTwoMessages(fullBuffer.length - 1),\r\n          splitAndVerifyTwoMessages(fullBuffer.length - 4),\r\n          splitAndVerifyTwoMessages(fullBuffer.length - 6),\r\n        ])\r\n      })\r\n\r\n      it('at the end', function () {\r\n        return Promise.all([splitAndVerifyTwoMessages(8), splitAndVerifyTwoMessages(1)])\r\n      })\r\n    })\r\n  })\r\n})\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/testing/test-buffers.ts","C:/repos/node-postgres/packages/pg-protocol/src/testing/buffer-list.ts","C:/repos/node-postgres/packages/pg-protocol/src/index.ts","C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\index.ts",{"fileContent":"import { BackendMessage, DatabaseError } from './messages'\r\nimport { serialize } from './serializer'\r\nimport { Parser, MessageCallback } from './parser'\r\n\r\nexport function parse(stream: NodeJS.ReadableStream, callback: MessageCallback): Promise<void> {\r\n  const parser = new Parser()\r\n  stream.on('data', (buffer: Buffer) => parser.parse(buffer, callback))\r\n\r\n  // only when the message \"ends\" ( a message boundery? ) so this kinda makes sense, sure\r\n  return new Promise((resolve) => stream.on('end', () => resolve()))\r\n}\r\n\r\nexport { serialize, DatabaseError }\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\buffer-reader.ts",{"fileContent":"const emptyBuffer = Buffer.allocUnsafe(0)\r\n\r\nexport class BufferReader {\r\n  private buffer: Buffer = emptyBuffer\r\n\r\n  // TODO(bmc): support non-utf8 encoding?\r\n  private encoding: string = 'utf-8'\r\n\r\n  constructor(private offset: number = 0) {}\r\n\r\n  public setBuffer(offset: number, buffer: Buffer): void {\r\n    this.offset = offset\r\n    this.buffer = buffer\r\n  }\r\n\r\n  public int16(): number {\r\n    const result = this.buffer.readInt16BE(this.offset)\r\n    this.offset += 2\r\n    return result\r\n  }\r\n\r\n  public byte(): number {\r\n    const result = this.buffer[this.offset]\r\n    this.offset++\r\n    return result\r\n  }\r\n\r\n  public int32(): number {\r\n    const result = this.buffer.readInt32BE(this.offset)\r\n    this.offset += 4\r\n    return result\r\n  }\r\n\r\n  public string(length: number): string {\r\n    const encoding = this.encoding\r\n    //@ts-ignore\r\n    const result = this.buffer.toString(encoding, this.offset, this.offset + length)\r\n    this.offset += length\r\n    return result\r\n  }\r\n\r\n  public cstring(): string {\r\n    const start = this.offset\r\n    let end = start\r\n    while (this.buffer[end++] !== 0) {}\r\n    this.offset = end\r\n    //@ts-ignore\r\n    return this.buffer.toString(this.encoding, start, end - 1)\r\n  }\r\n\r\n  public bytes(length: number): Buffer {\r\n    const result = this.buffer.slice(this.offset, this.offset + length)\r\n    this.offset += length\r\n    return result\r\n  }\r\n}\r\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\buffer-writer.ts",{"fileContent":"//binary data writer tuned for encoding binary specific to the postgres binary protocol\r\n\r\nexport class Writer {\r\n  private buffer: Buffer\r\n  private offset: number = 5\r\n  private headerPosition: number = 0\r\n  constructor(private size = 256) {\r\n    this.buffer = Buffer.allocUnsafe(size)\r\n  }\r\n\r\n  private ensure(size: number): void {\r\n    var remaining = this.buffer.length - this.offset\r\n    if (remaining < size) {\r\n      var oldBuffer = this.buffer\r\n      // exponential growth factor of around ~ 1.5\r\n      // https://stackoverflow.com/questions/2269063/buffer-growth-strategy\r\n      var newSize = oldBuffer.length + (oldBuffer.length >> 1) + size\r\n      this.buffer = Buffer.allocUnsafe(newSize)\r\n      oldBuffer.copy(this.buffer)\r\n    }\r\n  }\r\n\r\n  public addInt32(num: number): Writer {\r\n    this.ensure(4)\r\n    this.buffer[this.offset++] = (num >>> 24) & 0xff\r\n    this.buffer[this.offset++] = (num >>> 16) & 0xff\r\n    this.buffer[this.offset++] = (num >>> 8) & 0xff\r\n    this.buffer[this.offset++] = (num >>> 0) & 0xff\r\n    return this\r\n  }\r\n\r\n  public addInt16(num: number): Writer {\r\n    this.ensure(2)\r\n    this.buffer[this.offset++] = (num >>> 8) & 0xff\r\n    this.buffer[this.offset++] = (num >>> 0) & 0xff\r\n    return this\r\n  }\r\n\r\n  public addCString(string: string): Writer {\r\n    if (!string) {\r\n      this.ensure(1)\r\n    } else {\r\n      var len = Buffer.byteLength(string)\r\n      this.ensure(len + 1) // +1 for null terminator\r\n      this.buffer.write(string, this.offset, 'utf-8')\r\n      this.offset += len\r\n    }\r\n\r\n    this.buffer[this.offset++] = 0 // null terminator\r\n    return this\r\n  }\r\n\r\n  public addString(string: string = ''): Writer {\r\n    var len = Buffer.byteLength(string)\r\n    this.ensure(len)\r\n    this.buffer.write(string, this.offset)\r\n    this.offset += len\r\n    return this\r\n  }\r\n\r\n  public add(otherBuffer: Buffer): Writer {\r\n    this.ensure(otherBuffer.length)\r\n    otherBuffer.copy(this.buffer, this.offset)\r\n    this.offset += otherBuffer.length\r\n    return this\r\n  }\r\n\r\n  private join(code?: number): Buffer {\r\n    if (code) {\r\n      this.buffer[this.headerPosition] = code\r\n      //length is everything in this packet minus the code\r\n      const length = this.offset - (this.headerPosition + 1)\r\n      this.buffer.writeInt32BE(length, this.headerPosition + 1)\r\n    }\r\n    return this.buffer.slice(code ? 0 : 5, this.offset)\r\n  }\r\n\r\n  public flush(code?: number): Buffer {\r\n    var result = this.join(code)\r\n    this.offset = 5\r\n    this.headerPosition = 0\r\n    this.buffer = Buffer.allocUnsafe(this.size)\r\n    return result\r\n  }\r\n}\r\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\messages.ts",{"fileContent":"export type Mode = 'text' | 'binary'\r\n\r\nexport type MessageName =\r\n  | 'parseComplete'\r\n  | 'bindComplete'\r\n  | 'closeComplete'\r\n  | 'noData'\r\n  | 'portalSuspended'\r\n  | 'replicationStart'\r\n  | 'emptyQuery'\r\n  | 'copyDone'\r\n  | 'copyData'\r\n  | 'rowDescription'\r\n  | 'parameterDescription'\r\n  | 'parameterStatus'\r\n  | 'backendKeyData'\r\n  | 'notification'\r\n  | 'readyForQuery'\r\n  | 'commandComplete'\r\n  | 'dataRow'\r\n  | 'copyInResponse'\r\n  | 'copyOutResponse'\r\n  | 'authenticationOk'\r\n  | 'authenticationMD5Password'\r\n  | 'authenticationCleartextPassword'\r\n  | 'authenticationSASL'\r\n  | 'authenticationSASLContinue'\r\n  | 'authenticationSASLFinal'\r\n  | 'error'\r\n  | 'notice'\r\n\r\nexport interface BackendMessage {\r\n  name: MessageName\r\n  length: number\r\n}\r\n\r\nexport const parseComplete: BackendMessage = {\r\n  name: 'parseComplete',\r\n  length: 5,\r\n}\r\n\r\nexport const bindComplete: BackendMessage = {\r\n  name: 'bindComplete',\r\n  length: 5,\r\n}\r\n\r\nexport const closeComplete: BackendMessage = {\r\n  name: 'closeComplete',\r\n  length: 5,\r\n}\r\n\r\nexport const noData: BackendMessage = {\r\n  name: 'noData',\r\n  length: 5,\r\n}\r\n\r\nexport const portalSuspended: BackendMessage = {\r\n  name: 'portalSuspended',\r\n  length: 5,\r\n}\r\n\r\nexport const replicationStart: BackendMessage = {\r\n  name: 'replicationStart',\r\n  length: 4,\r\n}\r\n\r\nexport const emptyQuery: BackendMessage = {\r\n  name: 'emptyQuery',\r\n  length: 4,\r\n}\r\n\r\nexport const copyDone: BackendMessage = {\r\n  name: 'copyDone',\r\n  length: 4,\r\n}\r\n\r\ninterface NoticeOrError {\r\n  message?: string\r\n  severity?: string\r\n  code?: string\r\n  detail?: string\r\n  hint?: string\r\n  position?: string\r\n  internalPosition?: string\r\n  internalQuery?: string\r\n  where?: string\r\n  schema?: string\r\n  table?: string\r\n  column?: string\r\n  dataType?: string\r\n  constraint?: string\r\n  file?: string\r\n  line?: string\r\n  routine?: string\r\n}\r\n\r\nexport class DatabaseError extends Error implements NoticeOrError {\r\n  public severity?: string\r\n  public code?: string\r\n  public detail: string | undefined\r\n  public hint: string | undefined\r\n  public position: string | undefined\r\n  public internalPosition: string | undefined\r\n  public internalQuery: string | undefined\r\n  public where: string | undefined\r\n  public schema: string | undefined\r\n  public table: string | undefined\r\n  public column: string | undefined\r\n  public dataType: string | undefined\r\n  public constraint: string | undefined\r\n  public file: string | undefined\r\n  public line: string | undefined\r\n  public routine: string | undefined\r\n  constructor(message: string, public readonly length: number, public readonly name: MessageName) {\r\n    super(message)\r\n  }\r\n}\r\n\r\nexport class CopyDataMessage {\r\n  public readonly name = 'copyData'\r\n  constructor(public readonly length: number, public readonly chunk: Buffer) {}\r\n}\r\n\r\nexport class CopyResponse {\r\n  public readonly columnTypes: number[]\r\n  constructor(\r\n    public readonly length: number,\r\n    public readonly name: MessageName,\r\n    public readonly binary: boolean,\r\n    columnCount: number\r\n  ) {\r\n    this.columnTypes = new Array(columnCount)\r\n  }\r\n}\r\n\r\nexport class Field {\r\n  constructor(\r\n    public readonly name: string,\r\n    public readonly tableID: number,\r\n    public readonly columnID: number,\r\n    public readonly dataTypeID: number,\r\n    public readonly dataTypeSize: number,\r\n    public readonly dataTypeModifier: number,\r\n    public readonly format: Mode\r\n  ) {}\r\n}\r\n\r\nexport class RowDescriptionMessage {\r\n  public readonly name: MessageName = 'rowDescription'\r\n  public readonly fields: Field[]\r\n  constructor(public readonly length: number, public readonly fieldCount: number) {\r\n    this.fields = new Array(this.fieldCount)\r\n  }\r\n}\r\n\r\nexport class ParameterDescriptionMessage {\r\n  public readonly name: MessageName = 'parameterDescription'\r\n  public readonly dataTypeIDs: number[]\r\n  constructor(public readonly length: number, public readonly parameterCount: number) {\r\n    this.dataTypeIDs = new Array(this.parameterCount)\r\n  }\r\n}\r\n\r\nexport class ParameterStatusMessage {\r\n  public readonly name: MessageName = 'parameterStatus'\r\n  constructor(\r\n    public readonly length: number,\r\n    public readonly parameterName: string,\r\n    public readonly parameterValue: string\r\n  ) {}\r\n}\r\n\r\nexport class AuthenticationMD5Password implements BackendMessage {\r\n  public readonly name: MessageName = 'authenticationMD5Password'\r\n  constructor(public readonly length: number, public readonly salt: Buffer) {}\r\n}\r\n\r\nexport class BackendKeyDataMessage {\r\n  public readonly name: MessageName = 'backendKeyData'\r\n  constructor(public readonly length: number, public readonly processID: number, public readonly secretKey: number) {}\r\n}\r\n\r\nexport class NotificationResponseMessage {\r\n  public readonly name: MessageName = 'notification'\r\n  constructor(\r\n    public readonly length: number,\r\n    public readonly processId: number,\r\n    public readonly channel: string,\r\n    public readonly payload: string\r\n  ) {}\r\n}\r\n\r\nexport class ReadyForQueryMessage {\r\n  public readonly name: MessageName = 'readyForQuery'\r\n  constructor(public readonly length: number, public readonly status: string) {}\r\n}\r\n\r\nexport class CommandCompleteMessage {\r\n  public readonly name: MessageName = 'commandComplete'\r\n  constructor(public readonly length: number, public readonly text: string) {}\r\n}\r\n\r\nexport class DataRowMessage {\r\n  public readonly fieldCount: number\r\n  public readonly name: MessageName = 'dataRow'\r\n  constructor(public length: number, public fields: any[]) {\r\n    this.fieldCount = fields.length\r\n  }\r\n}\r\n\r\nexport class NoticeMessage implements BackendMessage, NoticeOrError {\r\n  constructor(public readonly length: number, public readonly message: string | undefined) {}\r\n  public readonly name = 'notice'\r\n  public severity: string | undefined\r\n  public code: string | undefined\r\n  public detail: string | undefined\r\n  public hint: string | undefined\r\n  public position: string | undefined\r\n  public internalPosition: string | undefined\r\n  public internalQuery: string | undefined\r\n  public where: string | undefined\r\n  public schema: string | undefined\r\n  public table: string | undefined\r\n  public column: string | undefined\r\n  public dataType: string | undefined\r\n  public constraint: string | undefined\r\n  public file: string | undefined\r\n  public line: string | undefined\r\n  public routine: string | undefined\r\n}\r\n","resolvedModuleNames":[]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\parser.ts",{"fileContent":"import { TransformOptions } from 'stream'\r\nimport {\r\n  Mode,\r\n  bindComplete,\r\n  parseComplete,\r\n  closeComplete,\r\n  noData,\r\n  portalSuspended,\r\n  copyDone,\r\n  replicationStart,\r\n  emptyQuery,\r\n  ReadyForQueryMessage,\r\n  CommandCompleteMessage,\r\n  CopyDataMessage,\r\n  CopyResponse,\r\n  NotificationResponseMessage,\r\n  RowDescriptionMessage,\r\n  ParameterDescriptionMessage,\r\n  Field,\r\n  DataRowMessage,\r\n  ParameterStatusMessage,\r\n  BackendKeyDataMessage,\r\n  DatabaseError,\r\n  BackendMessage,\r\n  MessageName,\r\n  AuthenticationMD5Password,\r\n  NoticeMessage,\r\n} from './messages'\r\nimport { BufferReader } from './buffer-reader'\r\nimport assert from 'assert'\r\n\r\n// every message is prefixed with a single bye\r\nconst CODE_LENGTH = 1\r\n// every message has an int32 length which includes itself but does\r\n// NOT include the code in the length\r\nconst LEN_LENGTH = 4\r\n\r\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH\r\n\r\nexport type Packet = {\r\n  code: number\r\n  packet: Buffer\r\n}\r\n\r\nconst emptyBuffer = Buffer.allocUnsafe(0)\r\n\r\ntype StreamOptions = TransformOptions & {\r\n  mode: Mode\r\n}\r\n\r\nconst enum MessageCodes {\r\n  DataRow = 0x44, // D\r\n  ParseComplete = 0x31, // 1\r\n  BindComplete = 0x32, // 2\r\n  CloseComplete = 0x33, // 3\r\n  CommandComplete = 0x43, // C\r\n  ReadyForQuery = 0x5a, // Z\r\n  NoData = 0x6e, // n\r\n  NotificationResponse = 0x41, // A\r\n  AuthenticationResponse = 0x52, // R\r\n  ParameterStatus = 0x53, // S\r\n  BackendKeyData = 0x4b, // K\r\n  ErrorMessage = 0x45, // E\r\n  NoticeMessage = 0x4e, // N\r\n  RowDescriptionMessage = 0x54, // T\r\n  ParameterDescriptionMessage = 0x74, // t\r\n  PortalSuspended = 0x73, // s\r\n  ReplicationStart = 0x57, // W\r\n  EmptyQuery = 0x49, // I\r\n  CopyIn = 0x47, // G\r\n  CopyOut = 0x48, // H\r\n  CopyDone = 0x63, // c\r\n  CopyData = 0x64, // d\r\n}\r\n\r\nexport type MessageCallback = (msg: BackendMessage) => void\r\n\r\nexport class Parser {\r\n  private buffer: Buffer = emptyBuffer\r\n  private bufferLength: number = 0\r\n  private bufferOffset: number = 0\r\n  private reader = new BufferReader()\r\n  private mode: Mode\r\n\r\n  // so far the \"index.ts\" calls the constructor without arguments\r\n  constructor(opts?: StreamOptions) {\r\n    if (opts?.mode === 'binary') {\r\n      throw new Error('Binary mode not supported yet')\r\n    }\r\n    this.mode = opts?.mode || 'text'\r\n  }\r\n\r\n  public parse(buffer: Buffer, callback: MessageCallback) {\r\n    this.mergeBuffer(buffer)\r\n    const bufferFullLength = this.bufferOffset + this.bufferLength\r\n    let offset = this.bufferOffset\r\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\r\n      // code is 1 byte long - it identifies the message type\r\n      const code = this.buffer[offset]\r\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\r\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH)\r\n      const fullMessageLength = CODE_LENGTH + length\r\n      if (fullMessageLength + offset <= bufferFullLength) {\r\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer)\r\n        callback(message)\r\n        offset += fullMessageLength\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n    if (offset === bufferFullLength) {\r\n      // No more use for the buffer\r\n      this.buffer = emptyBuffer\r\n      this.bufferLength = 0\r\n      this.bufferOffset = 0\r\n    } else {\r\n      // Adjust the cursors of remainingBuffer\r\n      this.bufferLength = bufferFullLength - offset\r\n      this.bufferOffset = offset\r\n    }\r\n  }\r\n\r\n  private mergeBuffer(buffer: Buffer): void {\r\n    if (this.bufferLength > 0) {\r\n      const newLength = this.bufferLength + buffer.byteLength\r\n      const newFullLength = newLength + this.bufferOffset\r\n      if (newFullLength > this.buffer.byteLength) {\r\n        // We can't concat the new buffer with the remaining one\r\n        let newBuffer: Buffer\r\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\r\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\r\n          newBuffer = this.buffer\r\n        } else {\r\n          // Allocate a new larger buffer\r\n          let newBufferLength = this.buffer.byteLength * 2\r\n          while (newLength >= newBufferLength) {\r\n            newBufferLength *= 2\r\n          }\r\n          newBuffer = Buffer.allocUnsafe(newBufferLength)\r\n        }\r\n        // Move the remaining buffer to the new one\r\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength)\r\n        this.buffer = newBuffer\r\n        this.bufferOffset = 0\r\n      }\r\n      // Concat the new buffer with the remaining one\r\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength)\r\n      this.bufferLength = newLength\r\n    } else {\r\n      this.buffer = buffer\r\n      this.bufferOffset = 0\r\n      this.bufferLength = buffer.byteLength\r\n    }\r\n  }\r\n\r\n  private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\r\n    switch (code) {\r\n      case MessageCodes.BindComplete:\r\n        return bindComplete\r\n      case MessageCodes.ParseComplete:\r\n        return parseComplete\r\n      case MessageCodes.CloseComplete:\r\n        return closeComplete\r\n      case MessageCodes.NoData:\r\n        return noData\r\n      case MessageCodes.PortalSuspended:\r\n        return portalSuspended\r\n      case MessageCodes.CopyDone:\r\n        return copyDone\r\n      case MessageCodes.ReplicationStart:\r\n        return replicationStart\r\n      case MessageCodes.EmptyQuery:\r\n        return emptyQuery\r\n      case MessageCodes.DataRow:\r\n        return this.parseDataRowMessage(offset, length, bytes)\r\n      case MessageCodes.CommandComplete:\r\n        return this.parseCommandCompleteMessage(offset, length, bytes)\r\n      case MessageCodes.ReadyForQuery:\r\n        return this.parseReadyForQueryMessage(offset, length, bytes)\r\n      case MessageCodes.NotificationResponse:\r\n        return this.parseNotificationMessage(offset, length, bytes)\r\n      case MessageCodes.AuthenticationResponse:\r\n        return this.parseAuthenticationResponse(offset, length, bytes)\r\n      case MessageCodes.ParameterStatus:\r\n        return this.parseParameterStatusMessage(offset, length, bytes)\r\n      case MessageCodes.BackendKeyData:\r\n        return this.parseBackendKeyData(offset, length, bytes)\r\n      case MessageCodes.ErrorMessage:\r\n        return this.parseErrorMessage(offset, length, bytes, 'error')\r\n      case MessageCodes.NoticeMessage:\r\n        return this.parseErrorMessage(offset, length, bytes, 'notice')\r\n      case MessageCodes.RowDescriptionMessage:\r\n        return this.parseRowDescriptionMessage(offset, length, bytes)\r\n      case MessageCodes.ParameterDescriptionMessage:\r\n        return this.parseParameterDescriptionMessage(offset, length, bytes)\r\n      case MessageCodes.CopyIn:\r\n        return this.parseCopyInMessage(offset, length, bytes)\r\n      case MessageCodes.CopyOut:\r\n        return this.parseCopyOutMessage(offset, length, bytes)\r\n      case MessageCodes.CopyData:\r\n        return this.parseCopyData(offset, length, bytes)\r\n      default:\r\n        assert.fail(`unknown message code: ${code.toString(16)}`)\r\n    }\r\n  }\r\n\r\n  private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const status = this.reader.string(1)\r\n    return new ReadyForQueryMessage(length, status)\r\n  }\r\n\r\n  private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const text = this.reader.cstring()\r\n    return new CommandCompleteMessage(length, text)\r\n  }\r\n\r\n  private parseCopyData(offset: number, length: number, bytes: Buffer) {\r\n    const chunk = bytes.slice(offset, offset + (length - 4))\r\n    return new CopyDataMessage(length, chunk)\r\n  }\r\n\r\n  private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\r\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse')\r\n  }\r\n\r\n  private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\r\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse')\r\n  }\r\n\r\n  private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const isBinary = this.reader.byte() !== 0\r\n    const columnCount = this.reader.int16()\r\n    const message = new CopyResponse(length, messageName, isBinary, columnCount)\r\n    for (let i = 0; i < columnCount; i++) {\r\n      message.columnTypes[i] = this.reader.int16()\r\n    }\r\n    return message\r\n  }\r\n\r\n  private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const processId = this.reader.int32()\r\n    const channel = this.reader.cstring()\r\n    const payload = this.reader.cstring()\r\n    return new NotificationResponseMessage(length, processId, channel, payload)\r\n  }\r\n\r\n  private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const fieldCount = this.reader.int16()\r\n    const message = new RowDescriptionMessage(length, fieldCount)\r\n    for (let i = 0; i < fieldCount; i++) {\r\n      message.fields[i] = this.parseField()\r\n    }\r\n    return message\r\n  }\r\n\r\n  private parseField(): Field {\r\n    const name = this.reader.cstring()\r\n    const tableID = this.reader.int32()\r\n    const columnID = this.reader.int16()\r\n    const dataTypeID = this.reader.int32()\r\n    const dataTypeSize = this.reader.int16()\r\n    const dataTypeModifier = this.reader.int32()\r\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary'\r\n    return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode)\r\n  }\r\n\r\n  private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const parameterCount = this.reader.int16()\r\n    const message = new ParameterDescriptionMessage(length, parameterCount)\r\n    for (let i = 0; i < parameterCount; i++) {\r\n      message.dataTypeIDs[i] = this.reader.int32()\r\n    }\r\n    return message\r\n  }\r\n\r\n  private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const fieldCount = this.reader.int16()\r\n    const fields: any[] = new Array(fieldCount)\r\n    for (let i = 0; i < fieldCount; i++) {\r\n      const len = this.reader.int32()\r\n      // a -1 for length means the value of the field is null\r\n      fields[i] = len === -1 ? null : this.reader.string(len)\r\n    }\r\n    return new DataRowMessage(length, fields)\r\n  }\r\n\r\n  private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const name = this.reader.cstring()\r\n    const value = this.reader.cstring()\r\n    return new ParameterStatusMessage(length, name, value)\r\n  }\r\n\r\n  private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const processID = this.reader.int32()\r\n    const secretKey = this.reader.int32()\r\n    return new BackendKeyDataMessage(length, processID, secretKey)\r\n  }\r\n\r\n  public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const code = this.reader.int32()\r\n    // TODO(bmc): maybe better types here\r\n    const message: BackendMessage & any = {\r\n      name: 'authenticationOk',\r\n      length,\r\n    }\r\n\r\n    switch (code) {\r\n      case 0: // AuthenticationOk\r\n        break\r\n      case 3: // AuthenticationCleartextPassword\r\n        if (message.length === 8) {\r\n          message.name = 'authenticationCleartextPassword'\r\n        }\r\n        break\r\n      case 5: // AuthenticationMD5Password\r\n        if (message.length === 12) {\r\n          message.name = 'authenticationMD5Password'\r\n          const salt = this.reader.bytes(4)\r\n          return new AuthenticationMD5Password(length, salt)\r\n        }\r\n        break\r\n      case 10: // AuthenticationSASL\r\n        message.name = 'authenticationSASL'\r\n        message.mechanisms = []\r\n        let mechanism: string\r\n        do {\r\n          mechanism = this.reader.cstring()\r\n\r\n          if (mechanism) {\r\n            message.mechanisms.push(mechanism)\r\n          }\r\n        } while (mechanism)\r\n        break\r\n      case 11: // AuthenticationSASLContinue\r\n        message.name = 'authenticationSASLContinue'\r\n        message.data = this.reader.string(length - 8)\r\n        break\r\n      case 12: // AuthenticationSASLFinal\r\n        message.name = 'authenticationSASLFinal'\r\n        message.data = this.reader.string(length - 8)\r\n        break\r\n      default:\r\n        throw new Error('Unknown authenticationOk message type ' + code)\r\n    }\r\n    return message\r\n  }\r\n\r\n  private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\r\n    this.reader.setBuffer(offset, bytes)\r\n    const fields: Record<string, string> = {}\r\n    let fieldType = this.reader.string(1)\r\n    while (fieldType !== '\\0') {\r\n      fields[fieldType] = this.reader.cstring()\r\n      fieldType = this.reader.string(1)\r\n    }\r\n\r\n    const messageValue = fields.M\r\n\r\n    const message =\r\n      name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name)\r\n\r\n    message.severity = fields.S\r\n    message.code = fields.C\r\n    message.detail = fields.D\r\n    message.hint = fields.H\r\n    message.position = fields.P\r\n    message.internalPosition = fields.p\r\n    message.internalQuery = fields.q\r\n    message.where = fields.W\r\n    message.schema = fields.s\r\n    message.table = fields.t\r\n    message.column = fields.c\r\n    message.dataType = fields.d\r\n    message.constraint = fields.n\r\n    message.file = fields.F\r\n    message.line = fields.L\r\n    message.routine = fields.R\r\n    return message\r\n  }\r\n}\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\serializer.ts",{"fileContent":"import { Writer } from './buffer-writer'\r\n\r\nconst enum code {\r\n  startup = 0x70,\r\n  query = 0x51,\r\n  parse = 0x50,\r\n  bind = 0x42,\r\n  execute = 0x45,\r\n  flush = 0x48,\r\n  sync = 0x53,\r\n  end = 0x58,\r\n  close = 0x43,\r\n  describe = 0x44,\r\n  copyFromChunk = 0x64,\r\n  copyDone = 0x63,\r\n  copyFail = 0x66,\r\n}\r\n\r\nconst writer = new Writer()\r\n\r\nconst startup = (opts: Record<string, string>): Buffer => {\r\n  // protocol version\r\n  writer.addInt16(3).addInt16(0)\r\n  for (const key of Object.keys(opts)) {\r\n    writer.addCString(key).addCString(opts[key])\r\n  }\r\n\r\n  writer.addCString('client_encoding').addCString('UTF8')\r\n\r\n  var bodyBuffer = writer.addCString('').flush()\r\n  // this message is sent without a code\r\n\r\n  var length = bodyBuffer.length + 4\r\n\r\n  return new Writer().addInt32(length).add(bodyBuffer).flush()\r\n}\r\n\r\nconst requestSsl = (): Buffer => {\r\n  const response = Buffer.allocUnsafe(8)\r\n  response.writeInt32BE(8, 0)\r\n  response.writeInt32BE(80877103, 4)\r\n  return response\r\n}\r\n\r\nconst password = (password: string): Buffer => {\r\n  return writer.addCString(password).flush(code.startup)\r\n}\r\n\r\nconst sendSASLInitialResponseMessage = function (mechanism: string, initialResponse: string): Buffer {\r\n  // 0x70 = 'p'\r\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse)\r\n\r\n  return writer.flush(code.startup)\r\n}\r\n\r\nconst sendSCRAMClientFinalMessage = function (additionalData: string): Buffer {\r\n  return writer.addString(additionalData).flush(code.startup)\r\n}\r\n\r\nconst query = (text: string): Buffer => {\r\n  return writer.addCString(text).flush(code.query)\r\n}\r\n\r\ntype ParseOpts = {\r\n  name?: string\r\n  types?: number[]\r\n  text: string\r\n}\r\n\r\nconst emptyArray: any[] = []\r\n\r\nconst parse = (query: ParseOpts): Buffer => {\r\n  // expect something like this:\r\n  // { name: 'queryName',\r\n  //   text: 'select * from blah',\r\n  //   types: ['int8', 'bool'] }\r\n\r\n  // normalize missing query names to allow for null\r\n  const name = query.name || ''\r\n  if (name.length > 63) {\r\n    /* eslint-disable no-console */\r\n    console.error('Warning! Postgres only supports 63 characters for query names.')\r\n    console.error('You supplied %s (%s)', name, name.length)\r\n    console.error('This can cause conflicts and silent errors executing queries')\r\n    /* eslint-enable no-console */\r\n  }\r\n\r\n  const types = query.types || emptyArray\r\n\r\n  var len = types.length\r\n\r\n  var buffer = writer\r\n    .addCString(name) // name of query\r\n    .addCString(query.text) // actual query text\r\n    .addInt16(len)\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    buffer.addInt32(types[i])\r\n  }\r\n\r\n  return writer.flush(code.parse)\r\n}\r\n\r\ntype ValueMapper = (param: any, index: number) => any\r\n\r\ntype BindOpts = {\r\n  portal?: string\r\n  binary?: boolean\r\n  statement?: string\r\n  values?: any[]\r\n  // optional map from JS value to postgres value per parameter\r\n  valueMapper?: ValueMapper\r\n}\r\n\r\nconst paramWriter = new Writer()\r\n\r\n// make this a const enum so typescript will inline the value\r\nconst enum ParamType {\r\n  STRING = 0,\r\n  BINARY = 1,\r\n}\r\n\r\nconst writeValues = function (values: any[], valueMapper?: ValueMapper): void {\r\n  for (let i = 0; i < values.length; i++) {\r\n    const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i]\r\n    if (mappedVal == null) {\r\n      // add the param type (string) to the writer\r\n      writer.addInt16(ParamType.STRING)\r\n      // write -1 to the param writer to indicate null\r\n      paramWriter.addInt32(-1)\r\n    } else if (mappedVal instanceof Buffer) {\r\n      // add the param type (binary) to the writer\r\n      writer.addInt16(ParamType.BINARY)\r\n      // add the buffer to the param writer\r\n      paramWriter.addInt32(mappedVal.length)\r\n      paramWriter.add(mappedVal)\r\n    } else {\r\n      // add the param type (string) to the writer\r\n      writer.addInt16(ParamType.STRING)\r\n      paramWriter.addInt32(Buffer.byteLength(mappedVal))\r\n      paramWriter.addString(mappedVal)\r\n    }\r\n  }\r\n}\r\n\r\nconst bind = (config: BindOpts = {}): Buffer => {\r\n  // normalize config\r\n  const portal = config.portal || ''\r\n  const statement = config.statement || ''\r\n  const binary = config.binary || false\r\n  const values = config.values || emptyArray\r\n  const len = values.length\r\n\r\n  writer.addCString(portal).addCString(statement)\r\n  writer.addInt16(len)\r\n\r\n  writeValues(values, config.valueMapper)\r\n\r\n  writer.addInt16(len)\r\n  writer.add(paramWriter.flush())\r\n\r\n  // format code\r\n  writer.addInt16(binary ? ParamType.BINARY : ParamType.STRING)\r\n  return writer.flush(code.bind)\r\n}\r\n\r\ntype ExecOpts = {\r\n  portal?: string\r\n  rows?: number\r\n}\r\n\r\nconst emptyExecute = Buffer.from([code.execute, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00])\r\n\r\nconst execute = (config?: ExecOpts): Buffer => {\r\n  // this is the happy path for most queries\r\n  if (!config || (!config.portal && !config.rows)) {\r\n    return emptyExecute\r\n  }\r\n\r\n  const portal = config.portal || ''\r\n  const rows = config.rows || 0\r\n\r\n  const portalLength = Buffer.byteLength(portal)\r\n  const len = 4 + portalLength + 1 + 4\r\n  // one extra bit for code\r\n  const buff = Buffer.allocUnsafe(1 + len)\r\n  buff[0] = code.execute\r\n  buff.writeInt32BE(len, 1)\r\n  buff.write(portal, 5, 'utf-8')\r\n  buff[portalLength + 5] = 0 // null terminate portal cString\r\n  buff.writeUInt32BE(rows, buff.length - 4)\r\n  return buff\r\n}\r\n\r\nconst cancel = (processID: number, secretKey: number): Buffer => {\r\n  const buffer = Buffer.allocUnsafe(16)\r\n  buffer.writeInt32BE(16, 0)\r\n  buffer.writeInt16BE(1234, 4)\r\n  buffer.writeInt16BE(5678, 6)\r\n  buffer.writeInt32BE(processID, 8)\r\n  buffer.writeInt32BE(secretKey, 12)\r\n  return buffer\r\n}\r\n\r\ntype PortalOpts = {\r\n  type: 'S' | 'P'\r\n  name?: string\r\n}\r\n\r\nconst cstringMessage = (code: code, string: string): Buffer => {\r\n  const stringLen = Buffer.byteLength(string)\r\n  const len = 4 + stringLen + 1\r\n  // one extra bit for code\r\n  const buffer = Buffer.allocUnsafe(1 + len)\r\n  buffer[0] = code\r\n  buffer.writeInt32BE(len, 1)\r\n  buffer.write(string, 5, 'utf-8')\r\n  buffer[len] = 0 // null terminate cString\r\n  return buffer\r\n}\r\n\r\nconst emptyDescribePortal = writer.addCString('P').flush(code.describe)\r\nconst emptyDescribeStatement = writer.addCString('S').flush(code.describe)\r\n\r\nconst describe = (msg: PortalOpts): Buffer => {\r\n  return msg.name\r\n    ? cstringMessage(code.describe, `${msg.type}${msg.name || ''}`)\r\n    : msg.type === 'P'\r\n    ? emptyDescribePortal\r\n    : emptyDescribeStatement\r\n}\r\n\r\nconst close = (msg: PortalOpts): Buffer => {\r\n  const text = `${msg.type}${msg.name || ''}`\r\n  return cstringMessage(code.close, text)\r\n}\r\n\r\nconst copyData = (chunk: Buffer): Buffer => {\r\n  return writer.add(chunk).flush(code.copyFromChunk)\r\n}\r\n\r\nconst copyFail = (message: string): Buffer => {\r\n  return cstringMessage(code.copyFail, message)\r\n}\r\n\r\nconst codeOnlyBuffer = (code: code): Buffer => Buffer.from([code, 0x00, 0x00, 0x00, 0x04])\r\n\r\nconst flushBuffer = codeOnlyBuffer(code.flush)\r\nconst syncBuffer = codeOnlyBuffer(code.sync)\r\nconst endBuffer = codeOnlyBuffer(code.end)\r\nconst copyDoneBuffer = codeOnlyBuffer(code.copyDone)\r\n\r\nconst serialize = {\r\n  startup,\r\n  password,\r\n  requestSsl,\r\n  sendSASLInitialResponseMessage,\r\n  sendSCRAMClientFinalMessage,\r\n  query,\r\n  parse,\r\n  bind,\r\n  execute,\r\n  describe,\r\n  close,\r\n  flush: () => flushBuffer,\r\n  sync: () => syncBuffer,\r\n  end: () => endBuffer,\r\n  copyData,\r\n  copyDone: () => copyDoneBuffer,\r\n  copyFail,\r\n  cancel,\r\n}\r\n\r\nexport { serialize }\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts"]}],["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\b.ts",{"fileContent":"// file for microbenchmarking\r\n\r\nimport { Writer } from './buffer-writer'\r\nimport { serialize } from './index'\r\nimport { BufferReader } from './buffer-reader'\r\n\r\nconst LOOPS = 1000\r\nlet count = 0\r\nlet start = Date.now()\r\nconst writer = new Writer()\r\n\r\nconst reader = new BufferReader()\r\nconst buffer = Buffer.from([33, 33, 33, 33, 33, 33, 33, 0])\r\n\r\nconst run = () => {\r\n  if (count > LOOPS) {\r\n    console.log(Date.now() - start)\r\n    return\r\n  }\r\n  count++\r\n  for (let i = 0; i < LOOPS; i++) {\r\n    reader.setBuffer(0, buffer)\r\n    reader.cstring()\r\n  }\r\n  setImmediate(run)\r\n}\r\n\r\nrun()\r\n","resolvedModuleNames":["C:/repos/node-postgres/packages/pg-protocol/src/buffer-writer.ts","C:/repos/node-postgres/packages/pg-protocol/src/index.ts","C:/repos/node-postgres/packages/pg-protocol/src/buffer-reader.ts","C:/repos/node-postgres/packages/pg-protocol/src/messages.ts","C:/repos/node-postgres/packages/pg-protocol/src/serializer.ts","C:/repos/node-postgres/packages/pg-protocol/src/parser.ts"]}]]