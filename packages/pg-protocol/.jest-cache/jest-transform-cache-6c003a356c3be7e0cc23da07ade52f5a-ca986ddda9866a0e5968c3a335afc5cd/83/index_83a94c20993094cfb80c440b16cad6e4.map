{"file":"C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\index.ts","mappings":";;;AAAA,yCAA+D;AAY3C,8FAZS,wBAAa,OAYT;AAXjC,6CAAyC;AAWhC,0FAXA,sBAAS,OAWA;AAVlB,qCAAmD;AAEnD,SAAgB,KAAK,CAAC,MAA6B,EAAE,QAAyB;IAC1E,MAAM,MAAM,GAAG,IAAI,eAAM,EAAE,CAAC;IAC5B,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,MAAc,EAAE,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,CAAC;IAEtE,uFAAuF;IACvF,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AACvE,CAAC;AAND,sBAMC","names":[],"sources":["C:\\repos\\node-postgres\\packages\\pg-protocol\\src\\index.ts"],"sourcesContent":["import { /*BackendMessage,*/ DatabaseError } from './messages';\r\nimport { serialize } from './serializer';\r\nimport { Parser, MessageCallback } from './parser';\r\n\r\nexport function parse(stream: NodeJS.ReadableStream, callback: MessageCallback): Promise<void> {\r\n    const parser = new Parser();\r\n    stream.on('data', (buffer: Buffer) => parser.parse(buffer, callback));\r\n\r\n    // only when the message \"ends\" ( a message boundery? ) so this kinda makes sense, sure\r\n    return new Promise((resolve) => stream.on('end', () => resolve()));\r\n}\r\n\r\nexport { serialize, DatabaseError };\r\n"],"version":3}